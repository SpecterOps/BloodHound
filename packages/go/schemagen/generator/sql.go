// Copyright 2025 Specter Ops, Inc.
//
// Licensed under the Apache License, Version 2.0
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//	http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0
package generator

import (
	"fmt"
	"os"
	"path"
	"strings"

	"github.com/specterops/bloodhound/packages/go/schemagen/model"
)

type nodeIcon struct {
	Icon  string
	Color string
}

var nodeIcons = map[string]nodeIcon{
	// Active Directory Node Types
	"User": {
		Icon:  "fa-user",
		Color: "#17E625",
	},
	"Group": {
		Icon:  "fa-users",
		Color: "#DBE617",
	},
	"Computer": {
		Icon:  "fa-desktop",
		Color: "#E67873",
	},
	"Domain": {
		Icon:  "fa-globe",
		Color: "#17E6B9",
	},
	"GPO": {
		Icon:  "fa-list",
		Color: "#998EFD",
	},
	"AIACA": {
		Icon:  "fa-arrows-left-right-to-line",
		Color: "#9769F0",
	},
	"RootCA": {
		Icon:  "fa-landmark",
		Color: "#6968E8",
	},
	"EnterpriseCA": {
		Icon:  "fa-building",
		Color: "#4696E9",
	},
	"NTAuthStore": {
		Icon:  "fa-store",
		Color: "#D575F5",
	},
	"CertTemplate": {
		Icon:  "fa-id-card",
		Color: "#B153F3",
	},
	"IssuancePolicy": {
		Icon:  "fa-clipboard-check",
		Color: "#99B2DD",
	},
	"OU": {
		Icon:  "fa-sitemap",
		Color: "#FFAA00",
	},
	"Container": {
		Icon:  "fa-box",
		Color: "#F79A78",
	},
	// Azure Node Types
	"AZUser": {
		Icon:  "fa-user",
		Color: "#34D2EB",
	},
	"AZGroup": {
		Icon:  "fa-users",
		Color: "#F57C9B",
	},
	"AZTenant": {
		Icon:  "fa-cloud",
		Color: "#54F2F2",
	},
	"AZSubscription": {
		Icon:  "fa-key",
		Color: "#D2CCA1",
	},
	"AZResourceGroup": {
		Icon:  "fa-cube",
		Color: "#89BD9E",
	},
	"AZVM": {
		Icon:  "fa-desktop",
		Color: "#F9ADA0",
	},
	"AZWebApp": {
		Icon:  "fa-object-group",
		Color: "#4696E9",
	},
	"AZLogicApp": {
		Icon:  "fa-sitemap",
		Color: "#9EE047",
	},
	"AZAutomationAccount": {
		Icon:  "fa-cog",
		Color: "#F4BA44",
	},
	"AZFunctionApp": {
		Icon:  "fa-bolt",
		Color: "#F4BA44",
	},
	"AZContainerRegistry": {
		Icon:  "fa-box-open",
		Color: "#0885D7",
	},
	"AZManagedCluster": {
		Icon:  "fa-cubes",
		Color: "#326CE5",
	},
	"AZDevice": {
		Icon:  "fa-desktop",
		Color: "#B18FCF",
	},
	"AZKeyVault": {
		Icon:  "fa-lock",
		Color: "#ED658C",
	},
	"AZApp": {
		Icon:  "fa-window-restore",
		Color: "#03FC84",
	},
	"AZVMScaleSet": {
		Icon:  "fa-server",
		Color: "#007CD0",
	},
	"AZServicePrincipal": {
		Icon:  "fa-robot",
		Color: "#C1D6D6",
	},
	"AZRole": {
		Icon:  "fa-clipboard-list",
		Color: "#ED8537",
	},
	"AZManagementGroup": {
		Icon:  "fa-sitemap",
		Color: "#BD93D8",
	},
}

func GenerateExtensionSQLActiveDirectory(dir string, adSchema model.ActiveDirectory) error {
	return GenerateExtensionSQL("AD", "Active Directory", "v0.0.1", dir, "ad_graph_schema.sql", adSchema.NodeKinds, adSchema.RelationshipKinds, adSchema.PathfindingRelationships)
}

func GenerateExtensionSQLAzure(dir string, azSchema model.Azure) error {
	return GenerateExtensionSQL("AZ", "Azure", "v0.0.1", dir, "az_graph_schema.sql", azSchema.NodeKinds, azSchema.RelationshipKinds, azSchema.PathfindingRelationships)
}

func GenerateExtensionSQL(name string, displayName string, version string, dir string, fileName string, nodeKinds []model.StringEnum, relationshipKinds []model.StringEnum, pathfindingRelationshipKinds []model.StringEnum) error {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("-- Code generated by Cuelang code gen. DO NOT EDIT!\n-- Cuelang source: %s/\n", SchemaSourceName))

	sb.WriteString("INSERT INTO kind (name) VALUES\n")

	for _, kind := range nodeKinds {
		sb.WriteString(fmt.Sprintf("\t('%s'),\n", kind.GetRepresentation()))
	}

	for i, kind := range relationshipKinds {
		sb.WriteString(fmt.Sprintf("\t('%s')", kind.GetRepresentation()))

		if i != len(relationshipKinds)-1 {
			sb.WriteString(",\n")
		}
	}

	sb.WriteString("\nON CONFLICT (name) DO NOTHING;\n\n")

	sb.WriteString(fmt.Sprintf("DELETE FROM schema_extensions WHERE name = '%s';\n\n", name))

	sb.WriteString("DO $$\nDECLARE\n\tnew_extension_id INT;\nBEGIN\n")

	sb.WriteString(fmt.Sprintf("\tINSERT INTO schema_extensions (name, display_name, version, is_builtin) VALUES ('%s', '%s', '%s', true) RETURNING id INTO new_extension_id;\n\n", name, displayName, version))

	sb.WriteString("\tINSERT INTO schema_node_kinds (schema_extension_id, name, display_name, description, is_display_kind, icon, icon_color) VALUES\n")

	for i, kind := range nodeKinds {
		if iconInfo, found := nodeIcons[kind.GetRepresentation()]; found {
			sb.WriteString(fmt.Sprintf("\t\t(new_extension_id, '%s', '%s', '', %t, '%s', '%s')", kind.GetRepresentation(), kind.GetName(), found, iconInfo.Icon, iconInfo.Color))
		} else {
			sb.WriteString(fmt.Sprintf("\t\t(new_extension_id, '%s', '%s', '', %t, '', '')", kind.GetRepresentation(), kind.GetName(), found))
		}

		if i != len(nodeKinds)-1 {
			sb.WriteString(",\n")
		}
	}

	sb.WriteString(";\n\n")

	sb.WriteString("\tINSERT INTO schema_edge_kinds (schema_extension_id, name, description, is_traversable) VALUES\n")

	traversableMap := make(map[string]struct{})

	for _, kind := range pathfindingRelationshipKinds {
		traversableMap[kind.GetRepresentation()] = struct{}{}
	}

	for i, kind := range relationshipKinds {
		_, traversable := traversableMap[kind.GetRepresentation()]

		sb.WriteString(fmt.Sprintf("\t\t(new_extension_id, '%s', '', %t)", kind.GetRepresentation(), traversable))

		if i != len(relationshipKinds)-1 {
			sb.WriteString(",\n")
		}
	}

	sb.WriteString(";\nEND $$;")

	if _, err := os.Stat(dir); err != nil {
		if !os.IsNotExist(err) {
			return err
		}

		if err := os.MkdirAll(dir, defaultPackageDirPermission); err != nil {
			return err
		}
	}

	if fout, err := os.OpenFile(path.Join(dir, fileName), fileOpenMode, defaultSourceFilePermission); err != nil {
		return err
	} else {
		defer fout.Close()

		_, err := fout.WriteString(sb.String())
		return err
	}
}
