-- Copyright 2025 Specter Ops, Inc.
--
-- Licensed under the Apache License, Version 2.0
-- you may not use this file except in compliance with the License.
-- You may obtain a copy of the License at
--
--     http://www.apache.org/licenses/LICENSE-2.0
--
-- Unless required by applicable law or agreed to in writing, software
-- distributed under the License is distributed on an "AS IS" BASIS,
-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-- See the License for the specific language governing permissions and
-- limitations under the License.
--
-- SPDX-License-Identifier: Apache-2.0

-- case: match p = allShortestPaths((s:NodeKind1)-[*..]->()) return p
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.start_id, e0.end_id, 1, exists (select 1 from edge e0 where n1.id = e0.start_id), e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.start_id join node n1 on n1.id = e0.end_id where n0.kind_ids operator (pg_catalog.\u0026\u0026) array [1]::int2[];","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.end_id, s1.depth + 1, exists (select 1 from edge e0 where n1.id = e0.start_id), e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.start_id = s1.next_id join node n1 on n1.id = e0.end_id where s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id) select edges_to_path(variadic ep0)::pathcomposite as p from s0;

-- case: match p = allShortestPaths((s:NodeKind1)-[*..]->({name: "123"})) return p
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.start_id, e0.end_id, 1, n1.properties -\u003e\u003e 'name' = '123', e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.start_id join node n1 on n1.id = e0.end_id where n0.kind_ids operator (pg_catalog.\u0026\u0026) array [1]::int2[];","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.end_id, s1.depth + 1, n1.properties -\u003e\u003e 'name' = '123', e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.start_id = s1.next_id join node n1 on n1.id = e0.end_id where s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id where s1.satisfied) select edges_to_path(variadic ep0)::pathcomposite as p from s0;

-- case: match p = allShortestPaths((s:NodeKind1)-[*..]->(e)) where e.name = '123' return p
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.start_id, e0.end_id, 1, n1.properties -\u003e\u003e 'name' = '123', e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.start_id join node n1 on n1.id = e0.end_id where n0.kind_ids operator (pg_catalog.\u0026\u0026) array [1]::int2[];","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.end_id, s1.depth + 1, n1.properties -\u003e\u003e 'name' = '123', e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.start_id = s1.next_id join node n1 on n1.id = e0.end_id where s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id where s1.satisfied) select edges_to_path(variadic ep0)::pathcomposite as p from s0;

-- case: match p=shortestPath((n:NodeKind1)-[:EdgeKind1*1..]->(m)) where 'admin_tier_0' in split(m.system_tags, ' ') and n.objectid ends with '-513' and n<>m return p limit 1000
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.start_id, e0.end_id, 1, 'admin_tier_0' = any (string_to_array(n1.properties -\u003e\u003e 'system_tags', ' ')::text[]), e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.start_id join node n1 on n1.id = e0.end_id where n0.properties -\u003e\u003e 'objectid' like '%-513' and n0.kind_ids operator (pg_catalog.\u0026\u0026) array [1]::int2[] and e0.kind_id = any (array [3]::int2[]);","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.end_id, s1.depth + 1, 'admin_tier_0' = any (string_to_array(n1.properties -\u003e\u003e 'system_tags', ' ')::text[]), e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.start_id = s1.next_id join node n1 on n1.id = e0.end_id where e0.kind_id = any (array [3]::int2[]) and s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id where s1.satisfied and n0.id <> n1.id) select edges_to_path(variadic ep0)::pathcomposite as p from s0 limit 1000;

-- case: match p=shortestPath((n:NodeKind1)-[:EdgeKind1*1..]->(m)) where 'admin_tier_0' in split(m.system_tags, ' ') and n.objectid ends with '-513' and m<>n return p limit 1000
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.start_id, e0.end_id, 1, 'admin_tier_0' = any (string_to_array(n1.properties -\u003e\u003e 'system_tags', ' ')::text[]), e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.start_id join node n1 on n1.id = e0.end_id where n0.properties -\u003e\u003e 'objectid' like '%-513' and n0.kind_ids operator (pg_catalog.\u0026\u0026) array [1]::int2[] and e0.kind_id = any (array [3]::int2[]);","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.end_id, s1.depth + 1, 'admin_tier_0' = any (string_to_array(n1.properties -\u003e\u003e 'system_tags', ' ')::text[]), e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.start_id = s1.next_id join node n1 on n1.id = e0.end_id where e0.kind_id = any (array [3]::int2[]) and s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id where s1.satisfied and n1.id <> n0.id) select edges_to_path(variadic ep0)::pathcomposite as p from s0 limit 1000;

-- case: match p=shortestPath((t:NodeKind1)<-[:EdgeKind1|EdgeKind2*1..]-(s:NodeKind2)) where coalesce(t.system_tags, '') contains 'admin_tier_0' and t.name =~ 'name.*' and s<>t return p limit 1000
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.end_id, e0.start_id, 1, n1.kind_ids operator (pg_catalog.\u0026\u0026) array [2]::int2[], e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.end_id join node n1 on n1.id = e0.start_id where coalesce(n0.properties -\u003e\u003e 'system_tags', '')::text like '%admin_tier_0%' and n0.properties -\u003e\u003e 'name' ~ 'name.*' and n0.kind_ids operator (pg_catalog.\u0026\u0026) array [1]::int2[] and e0.kind_id = any (array [3, 4]::int2[]);","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.start_id, s1.depth + 1, n1.kind_ids operator (pg_catalog.\u0026\u0026) array [2]::int2[], e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.end_id = s1.next_id join node n1 on n1.id = e0.start_id where e0.kind_id = any (array [3, 4]::int2[]) and s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id where s1.satisfied and n1.id <> n0.id) select edges_to_path(variadic ep0)::pathcomposite as p from s0 limit 1000;

-- case: match p=shortestPath((a)-[:NodeKind1*]->(b)) where id(a) = 1 and id(b) = 2 return p
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.start_id, e0.end_id, 1, n1.id = 2, e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.start_id join node n1 on n1.id = e0.end_id where n0.id = 1 and e0.kind_id = any (array [1]::int2[]);","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.end_id, s1.depth + 1, n1.id = 2, e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.start_id = s1.next_id join node n1 on n1.id = e0.end_id where e0.kind_id = any (array [1]::int2[]) and s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id where s1.satisfied) select edges_to_path(variadic ep0)::pathcomposite as p from s0;

-- case: match p=shortestPath((b)<-[:NodeKind1*]-(a)) where id(a) = 1 and id(b) = 2 return p
-- pgsql_params:{"pi0":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select e0.end_id, e0.start_id, 1, n1.id = 1, e0.start_id = e0.end_id, array [e0.id] from edge e0 join node n0 on n0.id = e0.end_id join node n1 on n1.id = e0.start_id where n0.id = 2 and e0.kind_id = any (array [1]::int2[]);","pi1":"insert into next_pathspace (root_id, next_id, depth, satisfied, is_cycle, path) select s1.root_id, e0.start_id, s1.depth + 1, n1.id = 1, e0.id = any (s1.path), s1.path || e0.id from pathspace s1 join edge e0 on e0.end_id = s1.next_id join node n1 on n1.id = e0.start_id where e0.kind_id = any (array [1]::int2[]) and s1.depth \u003c 10 and not s1.is_cycle;"}
with s0 as (with s1(root_id, next_id, depth, satisfied, is_cycle, path) as (select * from asp_harness(@pi0::text, @pi1::text, 10)) select (select array_agg((e0.id, e0.start_id, e0.end_id, e0.kind_id, e0.properties)::edgecomposite) from edge e0 where e0.id = any (s1.path)) as e0, s1.path as ep0, (n0.id, n0.kind_ids, n0.properties)::nodecomposite as n0, (n1.id, n1.kind_ids, n1.properties)::nodecomposite as n1 from s1 join node n0 on n0.id = s1.root_id join node n1 on n1.id = s1.next_id where s1.satisfied) select edges_to_path(variadic ep0)::pathcomposite as p from s0;

