diff --git a/dist/graphology.esm.js b/dist/graphology.esm.js
index aa67724e820dc5c46106feb6c6bc8c2df898eb35..0fa58c533324f1bb4b70de7f7f4e01c52e87f4c9 100644
--- a/dist/graphology.esm.js
+++ b/dist/graphology.esm.js
@@ -1,7 +1,7 @@
-import { EventEmitter } from 'events';
-import Iterator from 'obliterator/iterator';
-import take from 'obliterator/take';
-import chain from 'obliterator/chain';
+import { EventEmitter } from "events";
+import Iterator from "obliterator/iterator.js";
+import take from "obliterator/take.js";
+import chain from "obliterator/chain.js";
 
 /**
  * Graphology Utilities
@@ -31,7 +31,7 @@ function assignPolyfill() {
 
 let assign = assignPolyfill;
 
-if (typeof Object.assign === 'function') assign = Object.assign;
+if (typeof Object.assign === "function") assign = Object.assign;
 
 /**
  * Function returning the first matching edge for given path.
@@ -51,11 +51,11 @@ function getMatchingEdge(graph, source, target, type) {
 
   if (!sourceData) return edge;
 
-  if (type === 'mixed') {
+  if (type === "mixed") {
     edge =
       (sourceData.out && sourceData.out[target]) ||
       (sourceData.undirected && sourceData.undirected[target]);
-  } else if (type === 'directed') {
+  } else if (type === "directed") {
     edge = sourceData.out && sourceData.out[target];
   } else {
     edge = sourceData.undirected && sourceData.undirected[target];
@@ -72,7 +72,7 @@ function getMatchingEdge(graph, source, target, type) {
  */
 function isPlainObject(value) {
   return (
-    typeof value === 'object' && value !== null && value.constructor === Object
+    typeof value === "object" && value !== null && value.constructor === Object
   );
 }
 
@@ -102,7 +102,7 @@ function privateProperty(target, name, value) {
     enumerable: false,
     configurable: false,
     writable: true,
-    value
+    value,
   });
 }
 
@@ -116,10 +116,10 @@ function privateProperty(target, name, value) {
 function readOnlyProperty(target, name, value) {
   const descriptor = {
     enumerable: true,
-    configurable: true
+    configurable: true,
   };
 
-  if (typeof value === 'function') {
+  if (typeof value === "function") {
     descriptor.get = value;
   } else {
     descriptor.value = value;
@@ -166,7 +166,7 @@ function incrementalIdStartingFromRandomByte() {
 class GraphError extends Error {
   constructor(message) {
     super();
-    this.name = 'GraphError';
+    this.name = "GraphError";
     this.message = message;
   }
 }
@@ -174,10 +174,10 @@ class GraphError extends Error {
 class InvalidArgumentsGraphError extends GraphError {
   constructor(message) {
     super(message);
-    this.name = 'InvalidArgumentsGraphError';
+    this.name = "InvalidArgumentsGraphError";
 
     // This is V8 specific to enhance stack readability
-    if (typeof Error.captureStackTrace === 'function')
+    if (typeof Error.captureStackTrace === "function")
       Error.captureStackTrace(
         this,
         InvalidArgumentsGraphError.prototype.constructor
@@ -188,10 +188,10 @@ class InvalidArgumentsGraphError extends GraphError {
 class NotFoundGraphError extends GraphError {
   constructor(message) {
     super(message);
-    this.name = 'NotFoundGraphError';
+    this.name = "NotFoundGraphError";
 
     // This is V8 specific to enhance stack readability
-    if (typeof Error.captureStackTrace === 'function')
+    if (typeof Error.captureStackTrace === "function")
       Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);
   }
 }
@@ -199,10 +199,10 @@ class NotFoundGraphError extends GraphError {
 class UsageGraphError extends GraphError {
   constructor(message) {
     super(message);
-    this.name = 'UsageGraphError';
+    this.name = "UsageGraphError";
 
     // This is V8 specific to enhance stack readability
-    if (typeof Error.captureStackTrace === 'function')
+    if (typeof Error.captureStackTrace === "function")
       Error.captureStackTrace(this, UsageGraphError.prototype.constructor);
   }
 }
@@ -319,10 +319,10 @@ function EdgeData(undirected, key, source, target, attributes) {
 }
 
 EdgeData.prototype.attach = function () {
-  let outKey = 'out';
-  let inKey = 'in';
+  let outKey = "out";
+  let inKey = "in";
 
-  if (this.undirected) outKey = inKey = 'undirected';
+  if (this.undirected) outKey = inKey = "undirected";
 
   const source = this.source.key;
   const target = this.target.key;
@@ -337,19 +337,19 @@ EdgeData.prototype.attach = function () {
 };
 
 EdgeData.prototype.attachMulti = function () {
-  let outKey = 'out';
-  let inKey = 'in';
+  let outKey = "out";
+  let inKey = "in";
 
   const source = this.source.key;
   const target = this.target.key;
 
-  if (this.undirected) outKey = inKey = 'undirected';
+  if (this.undirected) outKey = inKey = "undirected";
 
   // Handling source
   const adj = this.source[outKey];
   const head = adj[target];
 
-  if (typeof head === 'undefined') {
+  if (typeof head === "undefined") {
     adj[target] = this;
 
     // Self-loop optimization
@@ -375,10 +375,10 @@ EdgeData.prototype.detach = function () {
   const source = this.source.key;
   const target = this.target.key;
 
-  let outKey = 'out';
-  let inKey = 'in';
+  let outKey = "out";
+  let inKey = "in";
 
-  if (this.undirected) outKey = inKey = 'undirected';
+  if (this.undirected) outKey = inKey = "undirected";
 
   delete this.source[outKey][target];
 
@@ -390,10 +390,10 @@ EdgeData.prototype.detachMulti = function () {
   const source = this.source.key;
   const target = this.target.key;
 
-  let outKey = 'out';
-  let inKey = 'in';
+  let outKey = "out";
+  let inKey = "in";
 
-  if (this.undirected) outKey = inKey = 'undirected';
+  if (this.undirected) outKey = inKey = "undirected";
 
   // Deleting from doubly-linked list
   if (this.previous === undefined) {
@@ -447,7 +447,7 @@ function findRelevantNodeData(
 ) {
   let nodeData, edgeData, arg1, arg2;
 
-  nodeOrEdge = '' + nodeOrEdge;
+  nodeOrEdge = "" + nodeOrEdge;
 
   if (mode === NODE) {
     nodeData = graph._nodes.get(nodeOrEdge);
@@ -460,7 +460,7 @@ function findRelevantNodeData(
     arg1 = nameOrEdge;
     arg2 = add1;
   } else if (mode === OPPOSITE) {
-    nameOrEdge = '' + nameOrEdge;
+    nameOrEdge = "" + nameOrEdge;
 
     edgeData = graph._edges.get(nameOrEdge);
 
@@ -564,11 +564,11 @@ function attachNodeAttributeSetter(Class, method, mode) {
     data.attributes[name] = value;
 
     // Emitting
-    this.emit('nodeAttributesUpdated', {
+    this.emit("nodeAttributesUpdated", {
       key: data.key,
-      type: 'set',
+      type: "set",
       attributes: data.attributes,
-      name
+      name,
     });
 
     return this;
@@ -587,7 +587,7 @@ function attachNodeAttributeUpdater(Class, method, mode) {
       add2
     );
 
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
         `Graph.${method}: updater should be a function.`
       );
@@ -598,11 +598,11 @@ function attachNodeAttributeUpdater(Class, method, mode) {
     attributes[name] = value;
 
     // Emitting
-    this.emit('nodeAttributesUpdated', {
+    this.emit("nodeAttributesUpdated", {
       key: data.key,
-      type: 'set',
+      type: "set",
       attributes: data.attributes,
-      name
+      name,
     });
 
     return this;
@@ -623,11 +623,11 @@ function attachNodeAttributeRemover(Class, method, mode) {
     delete data.attributes[name];
 
     // Emitting
-    this.emit('nodeAttributesUpdated', {
+    this.emit("nodeAttributesUpdated", {
       key: data.key,
-      type: 'remove',
+      type: "remove",
       attributes: data.attributes,
-      name
+      name,
     });
 
     return this;
@@ -653,10 +653,10 @@ function attachNodeAttributesReplacer(Class, method, mode) {
     data.attributes = attributes;
 
     // Emitting
-    this.emit('nodeAttributesUpdated', {
+    this.emit("nodeAttributesUpdated", {
       key: data.key,
-      type: 'replace',
-      attributes: data.attributes
+      type: "replace",
+      attributes: data.attributes,
     });
 
     return this;
@@ -682,11 +682,11 @@ function attachNodeAttributesMerger(Class, method, mode) {
     assign(data.attributes, attributes);
 
     // Emitting
-    this.emit('nodeAttributesUpdated', {
+    this.emit("nodeAttributesUpdated", {
       key: data.key,
-      type: 'merge',
+      type: "merge",
       attributes: data.attributes,
-      data: attributes
+      data: attributes,
     });
 
     return this;
@@ -704,7 +704,7 @@ function attachNodeAttributesUpdater(Class, method, mode) {
       add1
     );
 
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
         `Graph.${method}: provided updater is not a function.`
       );
@@ -712,10 +712,10 @@ function attachNodeAttributesUpdater(Class, method, mode) {
     data.attributes = updater(data.attributes);
 
     // Emitting
-    this.emit('nodeAttributesUpdated', {
+    this.emit("nodeAttributesUpdated", {
       key: data.key,
-      type: 'update',
-      attributes: data.attributes
+      type: "update",
+      attributes: data.attributes,
     });
 
     return this;
@@ -727,41 +727,41 @@ function attachNodeAttributesUpdater(Class, method, mode) {
  */
 const NODE_ATTRIBUTES_METHODS = [
   {
-    name: element => `get${element}Attribute`,
-    attacher: attachNodeAttributeGetter
+    name: (element) => `get${element}Attribute`,
+    attacher: attachNodeAttributeGetter,
   },
   {
-    name: element => `get${element}Attributes`,
-    attacher: attachNodeAttributesGetter
+    name: (element) => `get${element}Attributes`,
+    attacher: attachNodeAttributesGetter,
   },
   {
-    name: element => `has${element}Attribute`,
-    attacher: attachNodeAttributeChecker
+    name: (element) => `has${element}Attribute`,
+    attacher: attachNodeAttributeChecker,
   },
   {
-    name: element => `set${element}Attribute`,
-    attacher: attachNodeAttributeSetter
+    name: (element) => `set${element}Attribute`,
+    attacher: attachNodeAttributeSetter,
   },
   {
-    name: element => `update${element}Attribute`,
-    attacher: attachNodeAttributeUpdater
+    name: (element) => `update${element}Attribute`,
+    attacher: attachNodeAttributeUpdater,
   },
   {
-    name: element => `remove${element}Attribute`,
-    attacher: attachNodeAttributeRemover
+    name: (element) => `remove${element}Attribute`,
+    attacher: attachNodeAttributeRemover,
   },
   {
-    name: element => `replace${element}Attributes`,
-    attacher: attachNodeAttributesReplacer
+    name: (element) => `replace${element}Attributes`,
+    attacher: attachNodeAttributesReplacer,
   },
   {
-    name: element => `merge${element}Attributes`,
-    attacher: attachNodeAttributesMerger
+    name: (element) => `merge${element}Attributes`,
+    attacher: attachNodeAttributesMerger,
   },
   {
-    name: element => `update${element}Attributes`,
-    attacher: attachNodeAttributesUpdater
-  }
+    name: (element) => `update${element}Attributes`,
+    attacher: attachNodeAttributesUpdater,
+  },
 ];
 
 /**
@@ -770,18 +770,18 @@ const NODE_ATTRIBUTES_METHODS = [
  * @param {function} Graph - Target class.
  */
 function attachNodeAttributesMethods(Graph) {
-  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {
+  NODE_ATTRIBUTES_METHODS.forEach(function ({ name, attacher }) {
     // For nodes
-    attacher(Graph, name('Node'), NODE);
+    attacher(Graph, name("Node"), NODE);
 
     // For sources
-    attacher(Graph, name('Source'), SOURCE);
+    attacher(Graph, name("Source"), SOURCE);
 
     // For targets
-    attacher(Graph, name('Target'), TARGET);
+    attacher(Graph, name("Target"), TARGET);
 
     // For opposites
-    attacher(Graph, name('Opposite'), OPPOSITE);
+    attacher(Graph, name("Opposite"), OPPOSITE);
   });
 }
 
@@ -818,7 +818,7 @@ function attachEdgeAttributeGetter(Class, method, type) {
   Class.prototype[method] = function (element, name) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -829,8 +829,8 @@ function attachEdgeAttributeGetter(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element;
-      const target = '' + name;
+      const source = "" + element;
+      const target = "" + name;
 
       name = arguments[2];
 
@@ -841,12 +841,12 @@ function attachEdgeAttributeGetter(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -885,7 +885,7 @@ function attachEdgeAttributesGetter(Class, method, type) {
   Class.prototype[method] = function (element) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -896,8 +896,8 @@ function attachEdgeAttributesGetter(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element,
-        target = '' + arguments[1];
+      const source = "" + element,
+        target = "" + arguments[1];
 
       data = getMatchingEdge(this, source, target, type);
 
@@ -906,12 +906,12 @@ function attachEdgeAttributesGetter(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -952,7 +952,7 @@ function attachEdgeAttributeChecker(Class, method, type) {
   Class.prototype[method] = function (element, name) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -963,8 +963,8 @@ function attachEdgeAttributeChecker(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element;
-      const target = '' + name;
+      const source = "" + element;
+      const target = "" + name;
 
       name = arguments[2];
 
@@ -975,12 +975,12 @@ function attachEdgeAttributeChecker(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -1023,7 +1023,7 @@ function attachEdgeAttributeSetter(Class, method, type) {
   Class.prototype[method] = function (element, name, value) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -1034,8 +1034,8 @@ function attachEdgeAttributeSetter(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element;
-      const target = '' + name;
+      const source = "" + element;
+      const target = "" + name;
 
       name = arguments[2];
       value = arguments[3];
@@ -1047,12 +1047,12 @@ function attachEdgeAttributeSetter(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -1064,11 +1064,11 @@ function attachEdgeAttributeSetter(Class, method, type) {
     data.attributes[name] = value;
 
     // Emitting
-    this.emit('edgeAttributesUpdated', {
+    this.emit("edgeAttributesUpdated", {
       key: data.key,
-      type: 'set',
+      type: "set",
       attributes: data.attributes,
-      name
+      name,
     });
 
     return this;
@@ -1106,7 +1106,7 @@ function attachEdgeAttributeUpdater(Class, method, type) {
   Class.prototype[method] = function (element, name, updater) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -1117,8 +1117,8 @@ function attachEdgeAttributeUpdater(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element;
-      const target = '' + name;
+      const source = "" + element;
+      const target = "" + name;
 
       name = arguments[2];
       updater = arguments[3];
@@ -1130,12 +1130,12 @@ function attachEdgeAttributeUpdater(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -1144,7 +1144,7 @@ function attachEdgeAttributeUpdater(Class, method, type) {
         );
     }
 
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
         `Graph.${method}: updater should be a function.`
       );
@@ -1152,11 +1152,11 @@ function attachEdgeAttributeUpdater(Class, method, type) {
     data.attributes[name] = updater(data.attributes[name]);
 
     // Emitting
-    this.emit('edgeAttributesUpdated', {
+    this.emit("edgeAttributesUpdated", {
       key: data.key,
-      type: 'set',
+      type: "set",
       attributes: data.attributes,
-      name
+      name,
     });
 
     return this;
@@ -1191,7 +1191,7 @@ function attachEdgeAttributeRemover(Class, method, type) {
   Class.prototype[method] = function (element, name) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -1202,8 +1202,8 @@ function attachEdgeAttributeRemover(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element;
-      const target = '' + name;
+      const source = "" + element;
+      const target = "" + name;
 
       name = arguments[2];
 
@@ -1214,12 +1214,12 @@ function attachEdgeAttributeRemover(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -1231,11 +1231,11 @@ function attachEdgeAttributeRemover(Class, method, type) {
     delete data.attributes[name];
 
     // Emitting
-    this.emit('edgeAttributesUpdated', {
+    this.emit("edgeAttributesUpdated", {
       key: data.key,
-      type: 'remove',
+      type: "remove",
       attributes: data.attributes,
-      name
+      name,
     });
 
     return this;
@@ -1270,7 +1270,7 @@ function attachEdgeAttributesReplacer(Class, method, type) {
   Class.prototype[method] = function (element, attributes) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -1281,8 +1281,8 @@ function attachEdgeAttributesReplacer(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element,
-        target = '' + attributes;
+      const source = "" + element,
+        target = "" + attributes;
 
       attributes = arguments[2];
 
@@ -1293,12 +1293,12 @@ function attachEdgeAttributesReplacer(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -1315,10 +1315,10 @@ function attachEdgeAttributesReplacer(Class, method, type) {
     data.attributes = attributes;
 
     // Emitting
-    this.emit('edgeAttributesUpdated', {
+    this.emit("edgeAttributesUpdated", {
       key: data.key,
-      type: 'replace',
-      attributes: data.attributes
+      type: "replace",
+      attributes: data.attributes,
     });
 
     return this;
@@ -1353,7 +1353,7 @@ function attachEdgeAttributesMerger(Class, method, type) {
   Class.prototype[method] = function (element, attributes) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -1364,8 +1364,8 @@ function attachEdgeAttributesMerger(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element,
-        target = '' + attributes;
+      const source = "" + element,
+        target = "" + attributes;
 
       attributes = arguments[2];
 
@@ -1376,12 +1376,12 @@ function attachEdgeAttributesMerger(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -1398,11 +1398,11 @@ function attachEdgeAttributesMerger(Class, method, type) {
     assign(data.attributes, attributes);
 
     // Emitting
-    this.emit('edgeAttributesUpdated', {
+    this.emit("edgeAttributesUpdated", {
       key: data.key,
-      type: 'merge',
+      type: "merge",
       attributes: data.attributes,
-      data: attributes
+      data: attributes,
     });
 
     return this;
@@ -1437,7 +1437,7 @@ function attachEdgeAttributesUpdater(Class, method, type) {
   Class.prototype[method] = function (element, updater) {
     let data;
 
-    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
+    if (this.type !== "mixed" && type !== "mixed" && type !== this.type)
       throw new UsageGraphError(
         `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
       );
@@ -1448,8 +1448,8 @@ function attachEdgeAttributesUpdater(Class, method, type) {
           `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
         );
 
-      const source = '' + element,
-        target = '' + updater;
+      const source = "" + element,
+        target = "" + updater;
 
       updater = arguments[2];
 
@@ -1460,12 +1460,12 @@ function attachEdgeAttributesUpdater(Class, method, type) {
           `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
         );
     } else {
-      if (type !== 'mixed')
+      if (type !== "mixed")
         throw new UsageGraphError(
           `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
         );
 
-      element = '' + element;
+      element = "" + element;
       data = this._edges.get(element);
 
       if (!data)
@@ -1474,7 +1474,7 @@ function attachEdgeAttributesUpdater(Class, method, type) {
         );
     }
 
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
         `Graph.${method}: provided updater is not a function.`
       );
@@ -1482,10 +1482,10 @@ function attachEdgeAttributesUpdater(Class, method, type) {
     data.attributes = updater(data.attributes);
 
     // Emitting
-    this.emit('edgeAttributesUpdated', {
+    this.emit("edgeAttributesUpdated", {
       key: data.key,
-      type: 'update',
-      attributes: data.attributes
+      type: "update",
+      attributes: data.attributes,
     });
 
     return this;
@@ -1497,41 +1497,41 @@ function attachEdgeAttributesUpdater(Class, method, type) {
  */
 const EDGE_ATTRIBUTES_METHODS = [
   {
-    name: element => `get${element}Attribute`,
-    attacher: attachEdgeAttributeGetter
+    name: (element) => `get${element}Attribute`,
+    attacher: attachEdgeAttributeGetter,
   },
   {
-    name: element => `get${element}Attributes`,
-    attacher: attachEdgeAttributesGetter
+    name: (element) => `get${element}Attributes`,
+    attacher: attachEdgeAttributesGetter,
   },
   {
-    name: element => `has${element}Attribute`,
-    attacher: attachEdgeAttributeChecker
+    name: (element) => `has${element}Attribute`,
+    attacher: attachEdgeAttributeChecker,
   },
   {
-    name: element => `set${element}Attribute`,
-    attacher: attachEdgeAttributeSetter
+    name: (element) => `set${element}Attribute`,
+    attacher: attachEdgeAttributeSetter,
   },
   {
-    name: element => `update${element}Attribute`,
-    attacher: attachEdgeAttributeUpdater
+    name: (element) => `update${element}Attribute`,
+    attacher: attachEdgeAttributeUpdater,
   },
   {
-    name: element => `remove${element}Attribute`,
-    attacher: attachEdgeAttributeRemover
+    name: (element) => `remove${element}Attribute`,
+    attacher: attachEdgeAttributeRemover,
   },
   {
-    name: element => `replace${element}Attributes`,
-    attacher: attachEdgeAttributesReplacer
+    name: (element) => `replace${element}Attributes`,
+    attacher: attachEdgeAttributesReplacer,
   },
   {
-    name: element => `merge${element}Attributes`,
-    attacher: attachEdgeAttributesMerger
+    name: (element) => `merge${element}Attributes`,
+    attacher: attachEdgeAttributesMerger,
   },
   {
-    name: element => `update${element}Attributes`,
-    attacher: attachEdgeAttributesUpdater
-  }
+    name: (element) => `update${element}Attributes`,
+    attacher: attachEdgeAttributesUpdater,
+  },
 ];
 
 /**
@@ -1540,15 +1540,15 @@ const EDGE_ATTRIBUTES_METHODS = [
  * @param {function} Graph - Target class.
  */
 function attachEdgeAttributesMethods(Graph) {
-  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {
+  EDGE_ATTRIBUTES_METHODS.forEach(function ({ name, attacher }) {
     // For edges
-    attacher(Graph, name('Edge'), 'mixed');
+    attacher(Graph, name("Edge"), "mixed");
 
     // For directed edges
-    attacher(Graph, name('DirectedEdge'), 'directed');
+    attacher(Graph, name("DirectedEdge"), "directed");
 
     // For undirected edges
-    attacher(Graph, name('UndirectedEdge'), 'undirected');
+    attacher(Graph, name("UndirectedEdge"), "undirected");
   });
 }
 
@@ -1565,37 +1565,37 @@ function attachEdgeAttributesMethods(Graph) {
  */
 const EDGES_ITERATION = [
   {
-    name: 'edges',
-    type: 'mixed'
+    name: "edges",
+    type: "mixed",
   },
   {
-    name: 'inEdges',
-    type: 'directed',
-    direction: 'in'
+    name: "inEdges",
+    type: "directed",
+    direction: "in",
   },
   {
-    name: 'outEdges',
-    type: 'directed',
-    direction: 'out'
+    name: "outEdges",
+    type: "directed",
+    direction: "out",
   },
   {
-    name: 'inboundEdges',
-    type: 'mixed',
-    direction: 'in'
+    name: "inboundEdges",
+    type: "mixed",
+    direction: "in",
   },
   {
-    name: 'outboundEdges',
-    type: 'mixed',
-    direction: 'out'
+    name: "outboundEdges",
+    type: "mixed",
+    direction: "out",
   },
   {
-    name: 'directedEdges',
-    type: 'directed'
+    name: "directedEdges",
+    type: "directed",
   },
   {
-    name: 'undirectedEdges',
-    type: 'undirected'
-  }
+    name: "undirectedEdges",
+    type: "undirected",
+  },
 ];
 
 /**
@@ -1677,7 +1677,7 @@ function createIterator(object, avoid) {
   return new Iterator(function next() {
     do {
       if (!edgeData) {
-        if (i >= l) return {done: true};
+        if (i >= l) return { done: true };
 
         const k = keys[i++];
 
@@ -1701,8 +1701,8 @@ function createIterator(object, avoid) {
         target: edgeData.target.key,
         sourceAttributes: edgeData.source.attributes,
         targetAttributes: edgeData.target.attributes,
-        undirected: edgeData.undirected
-      }
+        undirected: edgeData.undirected,
+      },
     };
   });
 }
@@ -1776,7 +1776,7 @@ function createIteratorForKey(object, k) {
 
   if (edgeData.next !== undefined) {
     return new Iterator(function () {
-      if (!edgeData) return {done: true};
+      if (!edgeData) return { done: true };
 
       const value = {
         edge: edgeData.key,
@@ -1785,14 +1785,14 @@ function createIteratorForKey(object, k) {
         target: edgeData.target.key,
         sourceAttributes: edgeData.source.attributes,
         targetAttributes: edgeData.target.attributes,
-        undirected: edgeData.undirected
+        undirected: edgeData.undirected,
       };
 
       edgeData = edgeData.next;
 
       return {
         done: false,
-        value
+        value,
       };
     });
   }
@@ -1804,7 +1804,7 @@ function createIteratorForKey(object, k) {
     target: edgeData.target.key,
     sourceAttributes: edgeData.source.attributes,
     targetAttributes: edgeData.target.attributes,
-    undirected: edgeData.undirected
+    undirected: edgeData.undirected,
   });
 }
 
@@ -1818,18 +1818,18 @@ function createIteratorForKey(object, k) {
 function createEdgeArray(graph, type) {
   if (graph.size === 0) return [];
 
-  if (type === 'mixed' || type === graph.type) {
-    if (typeof Array.from === 'function')
+  if (type === "mixed" || type === graph.type) {
+    if (typeof Array.from === "function")
       return Array.from(graph._edges.keys());
 
     return take(graph._edges.keys(), graph._edges.size);
   }
 
   const size =
-    type === 'undirected' ? graph.undirectedSize : graph.directedSize;
+    type === "undirected" ? graph.undirectedSize : graph.directedSize;
 
   const list = new Array(size),
-    mask = type === 'undirected';
+    mask = type === "undirected";
 
   const iterator = graph._edges.values();
 
@@ -1856,8 +1856,8 @@ function createEdgeArray(graph, type) {
 function forEachEdge(breakable, graph, type, callback) {
   if (graph.size === 0) return;
 
-  const shouldFilter = type !== 'mixed' && type !== graph.type;
-  const mask = type === 'undirected';
+  const shouldFilter = type !== "mixed" && type !== graph.type;
+  const mask = type === "undirected";
 
   let step, data;
   let shouldBreak = false;
@@ -1868,7 +1868,7 @@ function forEachEdge(breakable, graph, type, callback) {
 
     if (shouldFilter && data.undirected !== mask) continue;
 
-    const {key, attributes, source, target} = data;
+    const { key, attributes, source, target } = data;
 
     shouldBreak = callback(
       key,
@@ -1896,8 +1896,8 @@ function forEachEdge(breakable, graph, type, callback) {
 function createEdgeIterator(graph, type) {
   if (graph.size === 0) return Iterator.empty();
 
-  const shouldFilter = type !== 'mixed' && type !== graph.type;
-  const mask = type === 'undirected';
+  const shouldFilter = type !== "mixed" && type !== graph.type;
+  const mask = type === "undirected";
 
   const iterator = graph._edges.values();
 
@@ -1924,10 +1924,10 @@ function createEdgeIterator(graph, type) {
       target: data.target.key,
       sourceAttributes: data.source.attributes,
       targetAttributes: data.target.attributes,
-      undirected: data.undirected
+      undirected: data.undirected,
     };
 
-    return {value, done: false};
+    return { value, done: false };
   });
 }
 
@@ -1952,13 +1952,13 @@ function forEachEdgeForNode(
 
   let found;
 
-  if (type !== 'undirected') {
-    if (direction !== 'out') {
+  if (type !== "undirected") {
+    if (direction !== "out") {
       found = fn(breakable, nodeData.in, callback);
 
       if (breakable && found) return found;
     }
-    if (direction !== 'in') {
+    if (direction !== "in") {
       found = fn(
         breakable,
         nodeData.out,
@@ -1970,7 +1970,7 @@ function forEachEdgeForNode(
     }
   }
 
-  if (type !== 'directed') {
+  if (type !== "directed") {
     found = fn(breakable, nodeData.undirected, callback);
 
     if (breakable && found) return found;
@@ -2009,17 +2009,17 @@ function createEdgeArrayForNode(multi, type, direction, nodeData) {
 function createEdgeIteratorForNode(type, direction, nodeData) {
   let iterator = Iterator.empty();
 
-  if (type !== 'undirected') {
-    if (direction !== 'out' && typeof nodeData.in !== 'undefined')
+  if (type !== "undirected") {
+    if (direction !== "out" && typeof nodeData.in !== "undefined")
       iterator = chain(iterator, createIterator(nodeData.in));
-    if (direction !== 'in' && typeof nodeData.out !== 'undefined')
+    if (direction !== "in" && typeof nodeData.out !== "undefined")
       iterator = chain(
         iterator,
         createIterator(nodeData.out, !direction ? nodeData.key : undefined)
       );
   }
 
-  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {
+  if (type !== "directed" && typeof nodeData.undirected !== "undefined") {
     iterator = chain(iterator, createIterator(nodeData.undirected));
   }
 
@@ -2050,16 +2050,16 @@ function forEachEdgeForPath(
 
   let found;
 
-  if (type !== 'undirected') {
-    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {
+  if (type !== "undirected") {
+    if (typeof sourceData.in !== "undefined" && direction !== "out") {
       found = fn(breakable, sourceData.in, target, callback);
 
       if (breakable && found) return found;
     }
 
     if (
-      typeof sourceData.out !== 'undefined' &&
-      direction !== 'in' &&
+      typeof sourceData.out !== "undefined" &&
+      direction !== "in" &&
       (direction || sourceData.key !== target)
     ) {
       found = fn(breakable, sourceData.out, target, callback);
@@ -2068,8 +2068,8 @@ function forEachEdgeForPath(
     }
   }
 
-  if (type !== 'directed') {
-    if (typeof sourceData.undirected !== 'undefined') {
+  if (type !== "directed") {
+    if (typeof sourceData.undirected !== "undefined") {
       found = fn(breakable, sourceData.undirected, target, callback);
 
       if (breakable && found) return found;
@@ -2119,26 +2119,26 @@ function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
 function createEdgeIteratorForPath(type, direction, sourceData, target) {
   let iterator = Iterator.empty();
 
-  if (type !== 'undirected') {
+  if (type !== "undirected") {
     if (
-      typeof sourceData.in !== 'undefined' &&
-      direction !== 'out' &&
+      typeof sourceData.in !== "undefined" &&
+      direction !== "out" &&
       target in sourceData.in
     )
       iterator = chain(iterator, createIteratorForKey(sourceData.in, target));
 
     if (
-      typeof sourceData.out !== 'undefined' &&
-      direction !== 'in' &&
+      typeof sourceData.out !== "undefined" &&
+      direction !== "in" &&
       target in sourceData.out &&
       (direction || sourceData.key !== target)
     )
       iterator = chain(iterator, createIteratorForKey(sourceData.out, target));
   }
 
-  if (type !== 'directed') {
+  if (type !== "directed") {
     if (
-      typeof sourceData.undirected !== 'undefined' &&
+      typeof sourceData.undirected !== "undefined" &&
       target in sourceData.undirected
     )
       iterator = chain(
@@ -2157,7 +2157,7 @@ function createEdgeIteratorForPath(type, direction, sourceData, target) {
  * @param {object}   description - Method description.
  */
 function attachEdgeArrayCreator(Class, description) {
-  const {name, type, direction} = description;
+  const { name, type, direction } = description;
 
   /**
    * Function returning an array of certain edges.
@@ -2177,17 +2177,17 @@ function attachEdgeArrayCreator(Class, description) {
    */
   Class.prototype[name] = function (source, target) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
       return [];
 
     if (!arguments.length) return createEdgeArray(this, type);
 
     if (arguments.length === 1) {
-      source = '' + source;
+      source = "" + source;
 
       const nodeData = this._nodes.get(source);
 
-      if (typeof nodeData === 'undefined')
+      if (typeof nodeData === "undefined")
         throw new NotFoundGraphError(
           `Graph.${name}: could not find the "${source}" node in the graph.`
         );
@@ -2195,15 +2195,15 @@ function attachEdgeArrayCreator(Class, description) {
       // Iterating over a node's edges
       return createEdgeArrayForNode(
         this.multi,
-        type === 'mixed' ? this.type : type,
+        type === "mixed" ? this.type : type,
         direction,
         nodeData
       );
     }
 
     if (arguments.length === 2) {
-      source = '' + source;
-      target = '' + target;
+      source = "" + source;
+      target = "" + target;
 
       const sourceData = this._nodes.get(source);
 
@@ -2240,9 +2240,9 @@ function attachEdgeArrayCreator(Class, description) {
  * @param {object}   description - Method description.
  */
 function attachForEachEdge(Class, description) {
-  const {name, type, direction} = description;
+  const { name, type, direction } = description;
 
-  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);
+  const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
 
   /**
    * Function iterating over the graph's relevant edges by applying the given
@@ -2266,7 +2266,7 @@ function attachForEachEdge(Class, description) {
    */
   Class.prototype[forEachName] = function (source, target, callback) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type) return;
 
     if (arguments.length === 1) {
       callback = source;
@@ -2274,12 +2274,12 @@ function attachForEachEdge(Class, description) {
     }
 
     if (arguments.length === 2) {
-      source = '' + source;
+      source = "" + source;
       callback = target;
 
       const nodeData = this._nodes.get(source);
 
-      if (typeof nodeData === 'undefined')
+      if (typeof nodeData === "undefined")
         throw new NotFoundGraphError(
           `Graph.${forEachName}: could not find the "${source}" node in the graph.`
         );
@@ -2289,7 +2289,7 @@ function attachForEachEdge(Class, description) {
       return forEachEdgeForNode(
         false,
         this.multi,
-        type === 'mixed' ? this.type : type,
+        type === "mixed" ? this.type : type,
         direction,
         nodeData,
         callback
@@ -2297,8 +2297,8 @@ function attachForEachEdge(Class, description) {
     }
 
     if (arguments.length === 3) {
-      source = '' + source;
-      target = '' + target;
+      source = "" + source;
+      target = "" + target;
 
       const sourceData = this._nodes.get(source);
 
@@ -2349,7 +2349,7 @@ function attachForEachEdge(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);
+  const mapName = "map" + name[0].toUpperCase() + name.slice(1);
 
   Class.prototype[mapName] = function () {
     const args = Array.prototype.slice.call(arguments);
@@ -2361,8 +2361,8 @@ function attachForEachEdge(Class, description) {
     if (args.length === 0) {
       let length = 0;
 
-      if (type !== 'directed') length += this.undirectedSize;
-      if (type !== 'undirected') length += this.directedSize;
+      if (type !== "directed") length += this.undirectedSize;
+      if (type !== "undirected") length += this.directedSize;
 
       result = new Array(length);
 
@@ -2408,7 +2408,7 @@ function attachForEachEdge(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);
+  const filterName = "filter" + name[0].toUpperCase() + name.slice(1);
 
   Class.prototype[filterName] = function () {
     const args = Array.prototype.slice.call(arguments);
@@ -2448,7 +2448,7 @@ function attachForEachEdge(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);
+  const reduceName = "reduce" + name[0].toUpperCase() + name.slice(1);
 
   Class.prototype[reduceName] = function () {
     let args = Array.prototype.slice.call(arguments);
@@ -2460,8 +2460,8 @@ function attachForEachEdge(Class, description) {
     }
 
     if (
-      typeof args[args.length - 1] === 'function' &&
-      typeof args[args.length - 2] !== 'function'
+      typeof args[args.length - 1] === "function" &&
+      typeof args[args.length - 2] !== "function"
     ) {
       throw new InvalidArgumentsGraphError(
         `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
@@ -2505,9 +2505,9 @@ function attachForEachEdge(Class, description) {
  * @param {object}   description - Method description.
  */
 function attachFindEdge(Class, description) {
-  const {name, type, direction} = description;
+  const { name, type, direction } = description;
 
-  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);
+  const findEdgeName = "find" + name[0].toUpperCase() + name.slice(1, -1);
 
   /**
    * Function iterating over the graph's relevant edges in order to match
@@ -2531,7 +2531,7 @@ function attachFindEdge(Class, description) {
    */
   Class.prototype[findEdgeName] = function (source, target, callback) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
       return false;
 
     if (arguments.length === 1) {
@@ -2540,12 +2540,12 @@ function attachFindEdge(Class, description) {
     }
 
     if (arguments.length === 2) {
-      source = '' + source;
+      source = "" + source;
       callback = target;
 
       const nodeData = this._nodes.get(source);
 
-      if (typeof nodeData === 'undefined')
+      if (typeof nodeData === "undefined")
         throw new NotFoundGraphError(
           `Graph.${findEdgeName}: could not find the "${source}" node in the graph.`
         );
@@ -2555,7 +2555,7 @@ function attachFindEdge(Class, description) {
       return forEachEdgeForNode(
         true,
         this.multi,
-        type === 'mixed' ? this.type : type,
+        type === "mixed" ? this.type : type,
         direction,
         nodeData,
         callback
@@ -2563,8 +2563,8 @@ function attachFindEdge(Class, description) {
     }
 
     if (arguments.length === 3) {
-      source = '' + source;
-      target = '' + target;
+      source = "" + source;
+      target = "" + target;
 
       const sourceData = this._nodes.get(source);
 
@@ -2615,7 +2615,7 @@ function attachFindEdge(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);
+  const someName = "some" + name[0].toUpperCase() + name.slice(1, -1);
 
   Class.prototype[someName] = function () {
     const args = Array.prototype.slice.call(arguments);
@@ -2652,7 +2652,7 @@ function attachFindEdge(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);
+  const everyName = "every" + name[0].toUpperCase() + name.slice(1, -1);
 
   Class.prototype[everyName] = function () {
     const args = Array.prototype.slice.call(arguments);
@@ -2677,9 +2677,9 @@ function attachFindEdge(Class, description) {
  * @param {object}   description - Method description.
  */
 function attachEdgeIteratorCreator(Class, description) {
-  const {name: originalName, type, direction} = description;
+  const { name: originalName, type, direction } = description;
 
-  const name = originalName.slice(0, -1) + 'Entries';
+  const name = originalName.slice(0, -1) + "Entries";
 
   /**
    * Function returning an iterator over the graph's edges.
@@ -2699,13 +2699,13 @@ function attachEdgeIteratorCreator(Class, description) {
    */
   Class.prototype[name] = function (source, target) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
       return Iterator.empty();
 
     if (!arguments.length) return createEdgeIterator(this, type);
 
     if (arguments.length === 1) {
-      source = '' + source;
+      source = "" + source;
 
       const sourceData = this._nodes.get(source);
 
@@ -2719,8 +2719,8 @@ function attachEdgeIteratorCreator(Class, description) {
     }
 
     if (arguments.length === 2) {
-      source = '' + source;
-      target = '' + target;
+      source = "" + source;
+      target = "" + target;
 
       const sourceData = this._nodes.get(source);
 
@@ -2750,7 +2750,7 @@ function attachEdgeIteratorCreator(Class, description) {
  * @param {function} Graph - Graph class.
  */
 function attachEdgeIterationMethods(Graph) {
-  EDGES_ITERATION.forEach(description => {
+  EDGES_ITERATION.forEach((description) => {
     attachEdgeArrayCreator(Graph, description);
     attachForEachEdge(Graph, description);
     attachFindEdge(Graph, description);
@@ -2771,37 +2771,37 @@ function attachEdgeIterationMethods(Graph) {
  */
 const NEIGHBORS_ITERATION = [
   {
-    name: 'neighbors',
-    type: 'mixed'
+    name: "neighbors",
+    type: "mixed",
   },
   {
-    name: 'inNeighbors',
-    type: 'directed',
-    direction: 'in'
+    name: "inNeighbors",
+    type: "directed",
+    direction: "in",
   },
   {
-    name: 'outNeighbors',
-    type: 'directed',
-    direction: 'out'
+    name: "outNeighbors",
+    type: "directed",
+    direction: "out",
   },
   {
-    name: 'inboundNeighbors',
-    type: 'mixed',
-    direction: 'in'
+    name: "inboundNeighbors",
+    type: "mixed",
+    direction: "in",
   },
   {
-    name: 'outboundNeighbors',
-    type: 'mixed',
-    direction: 'out'
+    name: "outboundNeighbors",
+    type: "mixed",
+    direction: "out",
   },
   {
-    name: 'directedNeighbors',
-    type: 'directed'
+    name: "directedNeighbors",
+    type: "directed",
   },
   {
-    name: 'undirectedNeighbors',
-    type: 'undirected'
-  }
+    name: "undirectedNeighbors",
+    type: "undirected",
+  },
 ];
 
 /**
@@ -2853,8 +2853,8 @@ function forEachInObjectOnce(breakable, visited, nodeData, object, callback) {
 
 function forEachNeighbor(breakable, type, direction, nodeData, callback) {
   // If we want only undirected or in or out, we can roll some optimizations
-  if (type !== 'mixed') {
-    if (type === 'undirected')
+  if (type !== "mixed") {
+    if (type === "undirected")
       return forEachInObjectOnce(
         breakable,
         null,
@@ -2863,7 +2863,7 @@ function forEachNeighbor(breakable, type, direction, nodeData, callback) {
         callback
       );
 
-    if (typeof direction === 'string')
+    if (typeof direction === "string")
       return forEachInObjectOnce(
         breakable,
         null,
@@ -2879,8 +2879,8 @@ function forEachNeighbor(breakable, type, direction, nodeData, callback) {
 
   let found;
 
-  if (type !== 'undirected') {
-    if (direction !== 'out') {
+  if (type !== "undirected") {
+    if (direction !== "out") {
       found = forEachInObjectOnce(
         breakable,
         null,
@@ -2893,7 +2893,7 @@ function forEachNeighbor(breakable, type, direction, nodeData, callback) {
 
       visited.wrap(nodeData.in);
     }
-    if (direction !== 'in') {
+    if (direction !== "in") {
       found = forEachInObjectOnce(
         breakable,
         visited,
@@ -2908,7 +2908,7 @@ function forEachNeighbor(breakable, type, direction, nodeData, callback) {
     }
   }
 
-  if (type !== 'directed') {
+  if (type !== "directed") {
     found = forEachInObjectOnce(
       breakable,
       visited,
@@ -2933,10 +2933,10 @@ function forEachNeighbor(breakable, type, direction, nodeData, callback) {
  */
 function createNeighborArrayForNode(type, direction, nodeData) {
   // If we want only undirected or in or out, we can roll some optimizations
-  if (type !== 'mixed') {
-    if (type === 'undirected') return Object.keys(nodeData.undirected);
+  if (type !== "mixed") {
+    if (type === "undirected") return Object.keys(nodeData.undirected);
 
-    if (typeof direction === 'string') return Object.keys(nodeData[direction]);
+    if (typeof direction === "string") return Object.keys(nodeData[direction]);
   }
 
   const neighbors = [];
@@ -2968,7 +2968,7 @@ function createDedupedObjectIterator(visited, nodeData, object) {
     do {
       if (i >= l) {
         if (visited) visited.wrap(object);
-        return {done: true};
+        return { done: true };
       }
 
       const edgeData = object[keys[i++]];
@@ -2986,18 +2986,21 @@ function createDedupedObjectIterator(visited, nodeData, object) {
 
     return {
       done: false,
-      value: {neighbor: neighborData.key, attributes: neighborData.attributes}
+      value: {
+        neighbor: neighborData.key,
+        attributes: neighborData.attributes,
+      },
     };
   });
 }
 
 function createNeighborIterator(type, direction, nodeData) {
   // If we want only undirected or in or out, we can roll some optimizations
-  if (type !== 'mixed') {
-    if (type === 'undirected')
+  if (type !== "mixed") {
+    if (type === "undirected")
       return createDedupedObjectIterator(null, nodeData, nodeData.undirected);
 
-    if (typeof direction === 'string')
+    if (typeof direction === "string")
       return createDedupedObjectIterator(null, nodeData, nodeData[direction]);
   }
 
@@ -3007,14 +3010,14 @@ function createNeighborIterator(type, direction, nodeData) {
   // We cheat by querying the other adjacencies
   const visited = new CompositeSetWrapper();
 
-  if (type !== 'undirected') {
-    if (direction !== 'out') {
+  if (type !== "undirected") {
+    if (direction !== "out") {
       iterator = chain(
         iterator,
         createDedupedObjectIterator(visited, nodeData, nodeData.in)
       );
     }
-    if (direction !== 'in') {
+    if (direction !== "in") {
       iterator = chain(
         iterator,
         createDedupedObjectIterator(visited, nodeData, nodeData.out)
@@ -3022,7 +3025,7 @@ function createNeighborIterator(type, direction, nodeData) {
     }
   }
 
-  if (type !== 'directed') {
+  if (type !== "directed") {
     iterator = chain(
       iterator,
       createDedupedObjectIterator(visited, nodeData, nodeData.undirected)
@@ -3039,7 +3042,7 @@ function createNeighborIterator(type, direction, nodeData) {
  * @param {object}   description - Method description.
  */
 function attachNeighborArrayCreator(Class, description) {
-  const {name, type, direction} = description;
+  const { name, type, direction } = description;
 
   /**
    * Function returning an array of certain neighbors.
@@ -3051,21 +3054,21 @@ function attachNeighborArrayCreator(Class, description) {
    */
   Class.prototype[name] = function (node) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
       return [];
 
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
-    if (typeof nodeData === 'undefined')
+    if (typeof nodeData === "undefined")
       throw new NotFoundGraphError(
         `Graph.${name}: could not find the "${node}" node in the graph.`
       );
 
     // Here, we want to iterate over a node's relevant neighbors
     return createNeighborArrayForNode(
-      type === 'mixed' ? this.type : type,
+      type === "mixed" ? this.type : type,
       direction,
       nodeData
     );
@@ -3079,9 +3082,9 @@ function attachNeighborArrayCreator(Class, description) {
  * @param {object}   description - Method description.
  */
 function attachForEachNeighbor(Class, description) {
-  const {name, type, direction} = description;
+  const { name, type, direction } = description;
 
-  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);
+  const forEachName = "forEach" + name[0].toUpperCase() + name.slice(1, -1);
 
   /**
    * Function iterating over all the relevant neighbors using a callback.
@@ -3094,13 +3097,13 @@ function attachForEachNeighbor(Class, description) {
    */
   Class.prototype[forEachName] = function (node, callback) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type) return;
 
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
-    if (typeof nodeData === 'undefined')
+    if (typeof nodeData === "undefined")
       throw new NotFoundGraphError(
         `Graph.${forEachName}: could not find the "${node}" node in the graph.`
       );
@@ -3108,7 +3111,7 @@ function attachForEachNeighbor(Class, description) {
     // Here, we want to iterate over a node's relevant neighbors
     forEachNeighbor(
       false,
-      type === 'mixed' ? this.type : type,
+      type === "mixed" ? this.type : type,
       direction,
       nodeData,
       callback
@@ -3123,7 +3126,7 @@ function attachForEachNeighbor(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);
+  const mapName = "map" + name[0].toUpperCase() + name.slice(1);
 
   Class.prototype[mapName] = function (node, callback) {
     // TODO: optimize when size is known beforehand
@@ -3144,7 +3147,7 @@ function attachForEachNeighbor(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);
+  const filterName = "filter" + name[0].toUpperCase() + name.slice(1);
 
   Class.prototype[filterName] = function (node, callback) {
     const result = [];
@@ -3164,7 +3167,7 @@ function attachForEachNeighbor(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);
+  const reduceName = "reduce" + name[0].toUpperCase() + name.slice(1);
 
   Class.prototype[reduceName] = function (node, callback, initialValue) {
     if (arguments.length < 3)
@@ -3190,11 +3193,11 @@ function attachForEachNeighbor(Class, description) {
  * @param {object}   description - Method description.
  */
 function attachFindNeighbor(Class, description) {
-  const {name, type, direction} = description;
+  const { name, type, direction } = description;
 
   const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);
 
-  const findName = 'find' + capitalizedSingular;
+  const findName = "find" + capitalizedSingular;
 
   /**
    * Function iterating over all the relevant neighbors using a callback.
@@ -3207,13 +3210,13 @@ function attachFindNeighbor(Class, description) {
    */
   Class.prototype[findName] = function (node, callback) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type) return;
 
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
-    if (typeof nodeData === 'undefined')
+    if (typeof nodeData === "undefined")
       throw new NotFoundGraphError(
         `Graph.${findName}: could not find the "${node}" node in the graph.`
       );
@@ -3221,7 +3224,7 @@ function attachFindNeighbor(Class, description) {
     // Here, we want to iterate over a node's relevant neighbors
     return forEachNeighbor(
       true,
-      type === 'mixed' ? this.type : type,
+      type === "mixed" ? this.type : type,
       direction,
       nodeData,
       callback
@@ -3238,7 +3241,7 @@ function attachFindNeighbor(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const someName = 'some' + capitalizedSingular;
+  const someName = "some" + capitalizedSingular;
 
   Class.prototype[someName] = function (node, callback) {
     const found = this[findName](node, callback);
@@ -3258,7 +3261,7 @@ function attachFindNeighbor(Class, description) {
    *
    * @throws {Error} - Will throw if there are too many arguments.
    */
-  const everyName = 'every' + capitalizedSingular;
+  const everyName = "every" + capitalizedSingular;
 
   Class.prototype[everyName] = function (node, callback) {
     const found = this[findName](node, (n, a) => {
@@ -3278,9 +3281,9 @@ function attachFindNeighbor(Class, description) {
  * @param {object}   description - Method description.
  */
 function attachNeighborIteratorCreator(Class, description) {
-  const {name, type, direction} = description;
+  const { name, type, direction } = description;
 
-  const iteratorName = name.slice(0, -1) + 'Entries';
+  const iteratorName = name.slice(0, -1) + "Entries";
 
   /**
    * Function returning an iterator over all the relevant neighbors.
@@ -3292,21 +3295,21 @@ function attachNeighborIteratorCreator(Class, description) {
    */
   Class.prototype[iteratorName] = function (node) {
     // Early termination
-    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
+    if (type !== "mixed" && this.type !== "mixed" && type !== this.type)
       return Iterator.empty();
 
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
-    if (typeof nodeData === 'undefined')
+    if (typeof nodeData === "undefined")
       throw new NotFoundGraphError(
         `Graph.${iteratorName}: could not find the "${node}" node in the graph.`
       );
 
     // Here, we want to iterate over a node's relevant neighbors
     return createNeighborIterator(
-      type === 'mixed' ? this.type : type,
+      type === "mixed" ? this.type : type,
       direction,
       nodeData
     );
@@ -3319,7 +3322,7 @@ function attachNeighborIteratorCreator(Class, description) {
  * @param {function} Graph - Graph class.
  */
 function attachNeighborIterationMethods(Graph) {
-  NEIGHBORS_ITERATION.forEach(description => {
+  NEIGHBORS_ITERATION.forEach((description) => {
     attachNeighborArrayCreator(Graph, description);
     attachForEachNeighbor(Graph, description);
     attachFindNeighbor(Graph, description);
@@ -3362,7 +3365,7 @@ function forEachAdjacency(
 
     sourceData = step.value;
 
-    if (type !== 'undirected') {
+    if (type !== "undirected") {
       adj = sourceData.out;
 
       for (neighbor in adj) {
@@ -3389,7 +3392,7 @@ function forEachAdjacency(
       }
     }
 
-    if (type !== 'directed') {
+    if (type !== "directed") {
       adj = sourceData.undirected;
 
       for (neighbor in adj) {
@@ -3453,7 +3456,7 @@ function forEachAdjacency(
  * @return {array}       - The serialized node.
  */
 function serializeNode(key, data) {
-  const serialized = {key};
+  const serialized = { key };
 
   if (!isEmpty(data.attributes))
     serialized.attributes = assign({}, data.attributes);
@@ -3473,13 +3476,13 @@ function serializeEdge(type, key, data) {
   const serialized = {
     key,
     source: data.source.key,
-    target: data.target.key
+    target: data.target.key,
   };
 
   if (!isEmpty(data.attributes))
     serialized.attributes = assign({}, data.attributes);
 
-  if (type === 'mixed' && data.undirected) serialized.undirected = true;
+  if (type === "mixed" && data.undirected) serialized.undirected = true;
 
   return serialized;
 }
@@ -3496,17 +3499,17 @@ function validateSerializedNode(value) {
       'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.'
     );
 
-  if (!('key' in value))
+  if (!("key" in value))
     throw new InvalidArgumentsGraphError(
-      'Graph.import: serialized node is missing its key.'
+      "Graph.import: serialized node is missing its key."
     );
 
   if (
-    'attributes' in value &&
+    "attributes" in value &&
     (!isPlainObject(value.attributes) || value.attributes === null)
   )
     throw new InvalidArgumentsGraphError(
-      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'
+      "Graph.import: invalid attributes. Attributes should be a plain object, null or omitted."
     );
 }
 
@@ -3522,27 +3525,27 @@ function validateSerializedEdge(value) {
       'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.'
     );
 
-  if (!('source' in value))
+  if (!("source" in value))
     throw new InvalidArgumentsGraphError(
-      'Graph.import: serialized edge is missing its source.'
+      "Graph.import: serialized edge is missing its source."
     );
 
-  if (!('target' in value))
+  if (!("target" in value))
     throw new InvalidArgumentsGraphError(
-      'Graph.import: serialized edge is missing its target.'
+      "Graph.import: serialized edge is missing its target."
     );
 
   if (
-    'attributes' in value &&
+    "attributes" in value &&
     (!isPlainObject(value.attributes) || value.attributes === null)
   )
     throw new InvalidArgumentsGraphError(
-      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'
+      "Graph.import: invalid attributes. Attributes should be a plain object, null or omitted."
     );
 
-  if ('undirected' in value && typeof value.undirected !== 'boolean')
+  if ("undirected" in value && typeof value.undirected !== "boolean")
     throw new InvalidArgumentsGraphError(
-      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'
+      "Graph.import: invalid undirectedness information. Undirected should be boolean or omitted."
     );
 }
 
@@ -3556,41 +3559,41 @@ const INSTANCE_ID = incrementalIdStartingFromRandomByte();
 /**
  * Enums.
  */
-const TYPES = new Set(['directed', 'undirected', 'mixed']);
+const TYPES = new Set(["directed", "undirected", "mixed"]);
 
 const EMITTER_PROPS = new Set([
-  'domain',
-  '_events',
-  '_eventsCount',
-  '_maxListeners'
+  "domain",
+  "_events",
+  "_eventsCount",
+  "_maxListeners",
 ]);
 
 const EDGE_ADD_METHODS = [
   {
-    name: verb => `${verb}Edge`,
-    generateKey: true
+    name: (verb) => `${verb}Edge`,
+    generateKey: true,
   },
   {
-    name: verb => `${verb}DirectedEdge`,
+    name: (verb) => `${verb}DirectedEdge`,
     generateKey: true,
-    type: 'directed'
+    type: "directed",
   },
   {
-    name: verb => `${verb}UndirectedEdge`,
+    name: (verb) => `${verb}UndirectedEdge`,
     generateKey: true,
-    type: 'undirected'
+    type: "undirected",
   },
   {
-    name: verb => `${verb}EdgeWithKey`
+    name: (verb) => `${verb}EdgeWithKey`,
   },
   {
-    name: verb => `${verb}DirectedEdgeWithKey`,
-    type: 'directed'
+    name: (verb) => `${verb}DirectedEdgeWithKey`,
+    type: "directed",
   },
   {
-    name: verb => `${verb}UndirectedEdgeWithKey`,
-    type: 'undirected'
-  }
+    name: (verb) => `${verb}UndirectedEdgeWithKey`,
+    type: "undirected",
+  },
 ];
 
 /**
@@ -3599,7 +3602,7 @@ const EDGE_ADD_METHODS = [
 const DEFAULTS = {
   allowSelfLoops: true,
   multi: false,
-  type: 'mixed'
+  type: "mixed",
 };
 
 /**
@@ -3621,7 +3624,7 @@ function addNode(graph, node, attributes) {
     );
 
   // String coercion
-  node = '' + node;
+  node = "" + node;
   attributes = attributes || {};
 
   if (graph._nodes.has(node))
@@ -3635,9 +3638,9 @@ function addNode(graph, node, attributes) {
   graph._nodes.set(node, data);
 
   // Emitting
-  graph.emit('nodeAdded', {
+  graph.emit("nodeAdded", {
     key: node,
-    attributes
+    attributes,
   });
 
   return data;
@@ -3652,9 +3655,9 @@ function unsafeAddNode(graph, node, attributes) {
 
   graph._nodes.set(node, data);
 
-  graph.emit('nodeAdded', {
+  graph.emit("nodeAdded", {
     key: node,
-    attributes
+    attributes,
   });
 
   return data;
@@ -3689,12 +3692,12 @@ function addEdge(
   attributes
 ) {
   // Checking validity of operation
-  if (!undirected && graph.type === 'undirected')
+  if (!undirected && graph.type === "undirected")
     throw new UsageGraphError(
       `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`
     );
 
-  if (undirected && graph.type === 'directed')
+  if (undirected && graph.type === "directed")
     throw new UsageGraphError(
       `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`
     );
@@ -3705,8 +3708,8 @@ function addEdge(
     );
 
   // Coercion of source & target:
-  source = '' + source;
-  target = '' + target;
+  source = "" + source;
+  target = "" + target;
   attributes = attributes || {};
 
   if (!graph.allowSelfLoops && source === target)
@@ -3733,7 +3736,7 @@ function addEdge(
     undirected,
     source,
     target,
-    attributes
+    attributes,
   };
 
   if (mustGenerateKey) {
@@ -3742,7 +3745,7 @@ function addEdge(
     edge = graph._edgeKeyGenerator();
   } else {
     // Coercion of edge key
-    edge = '' + edge;
+    edge = "" + edge;
 
     // Here, we have a key collision
     if (graph._edges.has(edge))
@@ -3755,8 +3758,8 @@ function addEdge(
   if (
     !graph.multi &&
     (undirected
-      ? typeof sourceData.undirected[target] !== 'undefined'
-      : typeof sourceData.out[target] !== 'undefined')
+      ? typeof sourceData.undirected[target] !== "undefined"
+      : typeof sourceData.out[target] !== "undefined")
   ) {
     throw new UsageGraphError(
       `Graph.${name}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`
@@ -3806,7 +3809,7 @@ function addEdge(
   // Emitting
   eventData.key = edge;
 
-  graph.emit('edgeAdded', eventData);
+  graph.emit("edgeAdded", eventData);
 
   return edge;
 }
@@ -3842,19 +3845,19 @@ function mergeEdge(
   asUpdater
 ) {
   // Checking validity of operation
-  if (!undirected && graph.type === 'undirected')
+  if (!undirected && graph.type === "undirected")
     throw new UsageGraphError(
       `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`
     );
 
-  if (undirected && graph.type === 'directed')
+  if (undirected && graph.type === "directed")
     throw new UsageGraphError(
       `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`
     );
 
   if (attributes) {
     if (asUpdater) {
-      if (typeof attributes !== 'function')
+      if (typeof attributes !== "function")
         throw new InvalidArgumentsGraphError(
           `Graph.${name}: invalid updater function. Expecting a function but got "${attributes}"`
         );
@@ -3867,8 +3870,8 @@ function mergeEdge(
   }
 
   // Coercion of source & target:
-  source = '' + source;
-  target = '' + target;
+  source = "" + source;
+  target = "" + target;
 
   let updater;
 
@@ -3932,10 +3935,10 @@ function mergeEdge(
       const oldAttributes = alreadyExistingEdgeData.attributes;
       alreadyExistingEdgeData.attributes = updater(oldAttributes);
 
-      graph.emit('edgeAttributesUpdated', {
-        type: 'replace',
+      graph.emit("edgeAttributesUpdated", {
+        type: "replace",
         key: alreadyExistingEdgeData.key,
-        attributes: alreadyExistingEdgeData.attributes
+        attributes: alreadyExistingEdgeData.attributes,
       });
     }
 
@@ -3943,11 +3946,11 @@ function mergeEdge(
     else {
       assign(alreadyExistingEdgeData.attributes, attributes);
 
-      graph.emit('edgeAttributesUpdated', {
-        type: 'merge',
+      graph.emit("edgeAttributesUpdated", {
+        type: "merge",
         key: alreadyExistingEdgeData.key,
         attributes: alreadyExistingEdgeData.attributes,
-        data: attributes
+        data: attributes,
       });
     }
 
@@ -3964,7 +3967,7 @@ function mergeEdge(
     undirected,
     source,
     target,
-    attributes
+    attributes,
   };
 
   if (mustGenerateKey) {
@@ -3973,7 +3976,7 @@ function mergeEdge(
     edge = graph._edgeKeyGenerator();
   } else {
     // Coercion of edge key
-    edge = '' + edge;
+    edge = "" + edge;
 
     // Here, we have a key collision
     if (graph._edges.has(edge))
@@ -4036,7 +4039,7 @@ function mergeEdge(
   // Emitting
   eventData.key = edge;
 
-  graph.emit('edgeAdded', eventData);
+  graph.emit("edgeAdded", eventData);
 
   return [edge, true, sourceWasAdded, targetWasAdded];
 }
@@ -4052,7 +4055,7 @@ function dropEdgeFromData(graph, edgeData) {
   graph._edges.delete(edgeData.key);
 
   // Updating related degrees
-  const {source: sourceData, target: targetData, attributes} = edgeData;
+  const { source: sourceData, target: targetData, attributes } = edgeData;
 
   const undirected = edgeData.undirected;
 
@@ -4084,12 +4087,12 @@ function dropEdgeFromData(graph, edgeData) {
   else graph._directedSize--;
 
   // Emitting
-  graph.emit('edgeDropped', {
+  graph.emit("edgeDropped", {
     key: edgeData.key,
     attributes,
     source: sourceData.key,
     target: targetData.key,
-    undirected
+    undirected,
   });
 }
 
@@ -4113,7 +4116,7 @@ class Graph extends EventEmitter {
     options = assign({}, DEFAULTS, options);
 
     // Enforcing options validity
-    if (typeof options.multi !== 'boolean')
+    if (typeof options.multi !== "boolean")
       throw new InvalidArgumentsGraphError(
         `Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options.multi}".`
       );
@@ -4123,7 +4126,7 @@ class Graph extends EventEmitter {
         `Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options.type}".`
       );
 
-    if (typeof options.allowSelfLoops !== 'boolean')
+    if (typeof options.allowSelfLoops !== "boolean")
       throw new InvalidArgumentsGraphError(
         `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options.allowSelfLoops}".`
       );
@@ -4132,13 +4135,13 @@ class Graph extends EventEmitter {
 
     // Utilities
     const NodeDataClass =
-      options.type === 'mixed'
+      options.type === "mixed"
         ? MixedNodeData
-        : options.type === 'directed'
+        : options.type === "directed"
         ? DirectedNodeData
         : UndirectedNodeData;
 
-    privateProperty(this, 'NodeDataClass', NodeDataClass);
+    privateProperty(this, "NodeDataClass", NodeDataClass);
 
     // Internal edge key generator
 
@@ -4151,7 +4154,7 @@ class Graph extends EventEmitter {
 
     // It also ensures that automatically generated edge keys are unlikely
     // to produce collisions with arbitrary keys given by users.
-    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';
+    const instancePrefix = "geid_" + INSTANCE_ID() + "_";
     let edgeId = 0;
 
     const edgeKeyGenerator = () => {
@@ -4165,45 +4168,45 @@ class Graph extends EventEmitter {
     };
 
     // Indexes
-    privateProperty(this, '_attributes', {});
-    privateProperty(this, '_nodes', new Map());
-    privateProperty(this, '_edges', new Map());
-    privateProperty(this, '_directedSize', 0);
-    privateProperty(this, '_undirectedSize', 0);
-    privateProperty(this, '_directedSelfLoopCount', 0);
-    privateProperty(this, '_undirectedSelfLoopCount', 0);
-    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);
+    privateProperty(this, "_attributes", {});
+    privateProperty(this, "_nodes", new Map());
+    privateProperty(this, "_edges", new Map());
+    privateProperty(this, "_directedSize", 0);
+    privateProperty(this, "_undirectedSize", 0);
+    privateProperty(this, "_directedSelfLoopCount", 0);
+    privateProperty(this, "_undirectedSelfLoopCount", 0);
+    privateProperty(this, "_edgeKeyGenerator", edgeKeyGenerator);
 
     // Options
-    privateProperty(this, '_options', options);
+    privateProperty(this, "_options", options);
 
     // Emitter properties
-    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));
+    EMITTER_PROPS.forEach((prop) => privateProperty(this, prop, this[prop]));
 
     //-- Properties readers
-    readOnlyProperty(this, 'order', () => this._nodes.size);
-    readOnlyProperty(this, 'size', () => this._edges.size);
-    readOnlyProperty(this, 'directedSize', () => this._directedSize);
-    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);
+    readOnlyProperty(this, "order", () => this._nodes.size);
+    readOnlyProperty(this, "size", () => this._edges.size);
+    readOnlyProperty(this, "directedSize", () => this._directedSize);
+    readOnlyProperty(this, "undirectedSize", () => this._undirectedSize);
     readOnlyProperty(
       this,
-      'selfLoopCount',
+      "selfLoopCount",
       () => this._directedSelfLoopCount + this._undirectedSelfLoopCount
     );
     readOnlyProperty(
       this,
-      'directedSelfLoopCount',
+      "directedSelfLoopCount",
       () => this._directedSelfLoopCount
     );
     readOnlyProperty(
       this,
-      'undirectedSelfLoopCount',
+      "undirectedSelfLoopCount",
       () => this._undirectedSelfLoopCount
     );
-    readOnlyProperty(this, 'multi', this._options.multi);
-    readOnlyProperty(this, 'type', this._options.type);
-    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);
-    readOnlyProperty(this, 'implementation', () => 'graphology');
+    readOnlyProperty(this, "multi", this._options.multi);
+    readOnlyProperty(this, "type", this._options.type);
+    readOnlyProperty(this, "allowSelfLoops", this._options.allowSelfLoops);
+    readOnlyProperty(this, "implementation", () => "graphology");
   }
 
   _resetInstanceCounters() {
@@ -4225,7 +4228,7 @@ class Graph extends EventEmitter {
    * @return {boolean}
    */
   hasNode(node) {
-    return this._nodes.has('' + node);
+    return this._nodes.has("" + node);
   }
 
   /**
@@ -4244,17 +4247,17 @@ class Graph extends EventEmitter {
    */
   hasDirectedEdge(source, target) {
     // Early termination
-    if (this.type === 'undirected') return false;
+    if (this.type === "undirected") return false;
 
     if (arguments.length === 1) {
-      const edge = '' + source;
+      const edge = "" + source;
 
       const edgeData = this._edges.get(edge);
 
       return !!edgeData && !edgeData.undirected;
     } else if (arguments.length === 2) {
-      source = '' + source;
-      target = '' + target;
+      source = "" + source;
+      target = "" + target;
 
       // If the node source or the target is not in the graph we break
       const nodeData = this._nodes.get(source);
@@ -4286,17 +4289,17 @@ class Graph extends EventEmitter {
    */
   hasUndirectedEdge(source, target) {
     // Early termination
-    if (this.type === 'directed') return false;
+    if (this.type === "directed") return false;
 
     if (arguments.length === 1) {
-      const edge = '' + source;
+      const edge = "" + source;
 
       const edgeData = this._edges.get(edge);
 
       return !!edgeData && edgeData.undirected;
     } else if (arguments.length === 2) {
-      source = '' + source;
-      target = '' + target;
+      source = "" + source;
+      target = "" + target;
 
       // If the node source or the target is not in the graph we break
       const nodeData = this._nodes.get(source);
@@ -4328,12 +4331,12 @@ class Graph extends EventEmitter {
    */
   hasEdge(source, target) {
     if (arguments.length === 1) {
-      const edge = '' + source;
+      const edge = "" + source;
 
       return this._edges.has(edge);
     } else if (arguments.length === 2) {
-      source = '' + source;
-      target = '' + target;
+      source = "" + source;
+      target = "" + target;
 
       // If the node source or the target is not in the graph we break
       const nodeData = this._nodes.get(source);
@@ -4342,9 +4345,9 @@ class Graph extends EventEmitter {
 
       // Is there a directed edge pointing toward target?
       return (
-        (typeof nodeData.out !== 'undefined' &&
+        (typeof nodeData.out !== "undefined" &&
           nodeData.out.hasOwnProperty(target)) ||
-        (typeof nodeData.undirected !== 'undefined' &&
+        (typeof nodeData.undirected !== "undefined" &&
           nodeData.undirected.hasOwnProperty(target))
       );
     }
@@ -4366,14 +4369,14 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if source or target doesn't exist.
    */
   directedEdge(source, target) {
-    if (this.type === 'undirected') return;
+    if (this.type === "undirected") return;
 
-    source = '' + source;
-    target = '' + target;
+    source = "" + source;
+    target = "" + target;
 
     if (this.multi)
       throw new UsageGraphError(
-        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'
+        "Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead."
       );
 
     const sourceData = this._nodes.get(source);
@@ -4405,14 +4408,14 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if source or target doesn't exist.
    */
   undirectedEdge(source, target) {
-    if (this.type === 'directed') return;
+    if (this.type === "directed") return;
 
-    source = '' + source;
-    target = '' + target;
+    source = "" + source;
+    target = "" + target;
 
     if (this.multi)
       throw new UsageGraphError(
-        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'
+        "Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead."
       );
 
     const sourceData = this._nodes.get(source);
@@ -4447,11 +4450,11 @@ class Graph extends EventEmitter {
   edge(source, target) {
     if (this.multi)
       throw new UsageGraphError(
-        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'
+        "Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead."
       );
 
-    source = '' + source;
-    target = '' + target;
+    source = "" + source;
+    target = "" + target;
 
     const sourceData = this._nodes.get(source);
 
@@ -4483,8 +4486,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   areDirectedNeighbors(node, neighbor) {
-    node = '' + node;
-    neighbor = '' + neighbor;
+    node = "" + node;
+    neighbor = "" + neighbor;
 
     const nodeData = this._nodes.get(node);
 
@@ -4493,7 +4496,7 @@ class Graph extends EventEmitter {
         `Graph.areDirectedNeighbors: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return false;
+    if (this.type === "undirected") return false;
 
     return neighbor in nodeData.in || neighbor in nodeData.out;
   }
@@ -4508,8 +4511,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   areOutNeighbors(node, neighbor) {
-    node = '' + node;
-    neighbor = '' + neighbor;
+    node = "" + node;
+    neighbor = "" + neighbor;
 
     const nodeData = this._nodes.get(node);
 
@@ -4518,7 +4521,7 @@ class Graph extends EventEmitter {
         `Graph.areOutNeighbors: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return false;
+    if (this.type === "undirected") return false;
 
     return neighbor in nodeData.out;
   }
@@ -4533,8 +4536,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   areInNeighbors(node, neighbor) {
-    node = '' + node;
-    neighbor = '' + neighbor;
+    node = "" + node;
+    neighbor = "" + neighbor;
 
     const nodeData = this._nodes.get(node);
 
@@ -4543,7 +4546,7 @@ class Graph extends EventEmitter {
         `Graph.areInNeighbors: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return false;
+    if (this.type === "undirected") return false;
 
     return neighbor in nodeData.in;
   }
@@ -4558,8 +4561,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   areUndirectedNeighbors(node, neighbor) {
-    node = '' + node;
-    neighbor = '' + neighbor;
+    node = "" + node;
+    neighbor = "" + neighbor;
 
     const nodeData = this._nodes.get(node);
 
@@ -4568,7 +4571,7 @@ class Graph extends EventEmitter {
         `Graph.areUndirectedNeighbors: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'directed') return false;
+    if (this.type === "directed") return false;
 
     return neighbor in nodeData.undirected;
   }
@@ -4583,8 +4586,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   areNeighbors(node, neighbor) {
-    node = '' + node;
-    neighbor = '' + neighbor;
+    node = "" + node;
+    neighbor = "" + neighbor;
 
     const nodeData = this._nodes.get(node);
 
@@ -4593,11 +4596,11 @@ class Graph extends EventEmitter {
         `Graph.areNeighbors: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       if (neighbor in nodeData.in || neighbor in nodeData.out) return true;
     }
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       if (neighbor in nodeData.undirected) return true;
     }
 
@@ -4614,8 +4617,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   areInboundNeighbors(node, neighbor) {
-    node = '' + node;
-    neighbor = '' + neighbor;
+    node = "" + node;
+    neighbor = "" + neighbor;
 
     const nodeData = this._nodes.get(node);
 
@@ -4624,11 +4627,11 @@ class Graph extends EventEmitter {
         `Graph.areInboundNeighbors: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       if (neighbor in nodeData.in) return true;
     }
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       if (neighbor in nodeData.undirected) return true;
     }
 
@@ -4645,8 +4648,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   areOutboundNeighbors(node, neighbor) {
-    node = '' + node;
-    neighbor = '' + neighbor;
+    node = "" + node;
+    neighbor = "" + neighbor;
 
     const nodeData = this._nodes.get(node);
 
@@ -4655,11 +4658,11 @@ class Graph extends EventEmitter {
         `Graph.areOutboundNeighbors: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       if (neighbor in nodeData.out) return true;
     }
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       if (neighbor in nodeData.undirected) return true;
     }
 
@@ -4675,7 +4678,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   inDegree(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4684,7 +4687,7 @@ class Graph extends EventEmitter {
         `Graph.inDegree: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return 0;
+    if (this.type === "undirected") return 0;
 
     return nodeData.inDegree;
   }
@@ -4698,7 +4701,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   outDegree(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4707,7 +4710,7 @@ class Graph extends EventEmitter {
         `Graph.outDegree: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return 0;
+    if (this.type === "undirected") return 0;
 
     return nodeData.outDegree;
   }
@@ -4721,7 +4724,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   directedDegree(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4730,7 +4733,7 @@ class Graph extends EventEmitter {
         `Graph.directedDegree: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return 0;
+    if (this.type === "undirected") return 0;
 
     return nodeData.inDegree + nodeData.outDegree;
   }
@@ -4744,7 +4747,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   undirectedDegree(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4753,7 +4756,7 @@ class Graph extends EventEmitter {
         `Graph.undirectedDegree: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'directed') return 0;
+    if (this.type === "directed") return 0;
 
     return nodeData.undirectedDegree;
   }
@@ -4767,7 +4770,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   inboundDegree(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4778,11 +4781,11 @@ class Graph extends EventEmitter {
 
     let degree = 0;
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       degree += nodeData.undirectedDegree;
     }
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       degree += nodeData.inDegree;
     }
 
@@ -4798,7 +4801,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   outboundDegree(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4809,11 +4812,11 @@ class Graph extends EventEmitter {
 
     let degree = 0;
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       degree += nodeData.undirectedDegree;
     }
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       degree += nodeData.outDegree;
     }
 
@@ -4829,7 +4832,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   degree(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4840,11 +4843,11 @@ class Graph extends EventEmitter {
 
     let degree = 0;
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       degree += nodeData.undirectedDegree;
     }
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       degree += nodeData.inDegree + nodeData.outDegree;
     }
 
@@ -4860,7 +4863,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   inDegreeWithoutSelfLoops(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4869,7 +4872,7 @@ class Graph extends EventEmitter {
         `Graph.inDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return 0;
+    if (this.type === "undirected") return 0;
 
     return nodeData.inDegree - nodeData.directedLoops;
   }
@@ -4883,7 +4886,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   outDegreeWithoutSelfLoops(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4892,7 +4895,7 @@ class Graph extends EventEmitter {
         `Graph.outDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return 0;
+    if (this.type === "undirected") return 0;
 
     return nodeData.outDegree - nodeData.directedLoops;
   }
@@ -4906,7 +4909,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   directedDegreeWithoutSelfLoops(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4915,7 +4918,7 @@ class Graph extends EventEmitter {
         `Graph.directedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'undirected') return 0;
+    if (this.type === "undirected") return 0;
 
     return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;
   }
@@ -4929,7 +4932,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   undirectedDegreeWithoutSelfLoops(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4938,7 +4941,7 @@ class Graph extends EventEmitter {
         `Graph.undirectedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
       );
 
-    if (this.type === 'directed') return 0;
+    if (this.type === "directed") return 0;
 
     return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;
   }
@@ -4952,7 +4955,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   inboundDegreeWithoutSelfLoops(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4964,12 +4967,12 @@ class Graph extends EventEmitter {
     let degree = 0;
     let loops = 0;
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       degree += nodeData.undirectedDegree;
       loops += nodeData.undirectedLoops * 2;
     }
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       degree += nodeData.inDegree;
       loops += nodeData.directedLoops;
     }
@@ -4986,7 +4989,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   outboundDegreeWithoutSelfLoops(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -4998,12 +5001,12 @@ class Graph extends EventEmitter {
     let degree = 0;
     let loops = 0;
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       degree += nodeData.undirectedDegree;
       loops += nodeData.undirectedLoops * 2;
     }
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       degree += nodeData.outDegree;
       loops += nodeData.directedLoops;
     }
@@ -5020,7 +5023,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node isn't in the graph.
    */
   degreeWithoutSelfLoops(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -5032,12 +5035,12 @@ class Graph extends EventEmitter {
     let degree = 0;
     let loops = 0;
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       degree += nodeData.undirectedDegree;
       loops += nodeData.undirectedLoops * 2;
     }
 
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       degree += nodeData.inDegree + nodeData.outDegree;
       loops += nodeData.directedLoops * 2;
     }
@@ -5054,7 +5057,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the edge isn't in the graph.
    */
   source(edge) {
-    edge = '' + edge;
+    edge = "" + edge;
 
     const data = this._edges.get(edge);
 
@@ -5075,7 +5078,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the edge isn't in the graph.
    */
   target(edge) {
-    edge = '' + edge;
+    edge = "" + edge;
 
     const data = this._edges.get(edge);
 
@@ -5096,7 +5099,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the edge isn't in the graph.
    */
   extremities(edge) {
-    edge = '' + edge;
+    edge = "" + edge;
 
     const edgeData = this._edges.get(edge);
 
@@ -5119,8 +5122,8 @@ class Graph extends EventEmitter {
    *                   edge & node are not related.
    */
   opposite(node, edge) {
-    node = '' + node;
-    edge = '' + edge;
+    node = "" + node;
+    edge = "" + edge;
 
     const data = this._edges.get(edge);
 
@@ -5150,8 +5153,8 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
    */
   hasExtremity(edge, node) {
-    edge = '' + edge;
-    node = '' + node;
+    edge = "" + edge;
+    node = "" + node;
 
     const data = this._edges.get(edge);
 
@@ -5172,7 +5175,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the edge isn't in the graph.
    */
   isUndirected(edge) {
-    edge = '' + edge;
+    edge = "" + edge;
 
     const data = this._edges.get(edge);
 
@@ -5193,7 +5196,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the edge isn't in the graph.
    */
   isDirected(edge) {
-    edge = '' + edge;
+    edge = "" + edge;
 
     const data = this._edges.get(edge);
 
@@ -5214,7 +5217,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the edge isn't in the graph.
    */
   isSelfLoop(edge) {
-    edge = '' + edge;
+    edge = "" + edge;
 
     const data = this._edges.get(edge);
 
@@ -5261,7 +5264,7 @@ class Graph extends EventEmitter {
       );
 
     // String coercion
-    node = '' + node;
+    node = "" + node;
     attributes = attributes || {};
 
     // If the node already exists, we merge the attributes
@@ -5271,11 +5274,11 @@ class Graph extends EventEmitter {
       if (attributes) {
         assign(data.attributes, attributes);
 
-        this.emit('nodeAttributesUpdated', {
-          type: 'merge',
+        this.emit("nodeAttributesUpdated", {
+          type: "merge",
           key: node,
           attributes: data.attributes,
-          data: attributes
+          data: attributes,
         });
       }
       return [node, false];
@@ -5287,9 +5290,9 @@ class Graph extends EventEmitter {
     this._nodes.set(node, data);
 
     // Emitting
-    this.emit('nodeAdded', {
+    this.emit("nodeAdded", {
       key: node,
-      attributes
+      attributes,
     });
 
     return [node, true];
@@ -5304,13 +5307,13 @@ class Graph extends EventEmitter {
    * @return {any}                - The node.
    */
   updateNode(node, updater) {
-    if (updater && typeof updater !== 'function')
+    if (updater && typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
         `Graph.updateNode: invalid updater function. Expecting a function but got "${updater}"`
       );
 
     // String coercion
-    node = '' + node;
+    node = "" + node;
 
     // If the node already exists, we update the attributes
     let data = this._nodes.get(node);
@@ -5320,10 +5323,10 @@ class Graph extends EventEmitter {
         const oldAttributes = data.attributes;
         data.attributes = updater(oldAttributes);
 
-        this.emit('nodeAttributesUpdated', {
-          type: 'replace',
+        this.emit("nodeAttributesUpdated", {
+          type: "replace",
           key: node,
-          attributes: data.attributes
+          attributes: data.attributes,
         });
       }
       return [node, false];
@@ -5337,9 +5340,9 @@ class Graph extends EventEmitter {
     this._nodes.set(node, data);
 
     // Emitting
-    this.emit('nodeAdded', {
+    this.emit("nodeAdded", {
       key: node,
-      attributes
+      attributes,
     });
 
     return [node, true];
@@ -5354,7 +5357,7 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if the node doesn't exist.
    */
   dropNode(node) {
-    node = '' + node;
+    node = "" + node;
 
     const nodeData = this._nodes.get(node);
 
@@ -5367,7 +5370,7 @@ class Graph extends EventEmitter {
 
     // Removing attached edges
     // NOTE: we could be faster here, but this is such a pain to maintain
-    if (this.type !== 'undirected') {
+    if (this.type !== "undirected") {
       for (const neighbor in nodeData.out) {
         edgeData = nodeData.out[neighbor];
 
@@ -5387,7 +5390,7 @@ class Graph extends EventEmitter {
       }
     }
 
-    if (this.type !== 'directed') {
+    if (this.type !== "directed") {
       for (const neighbor in nodeData.undirected) {
         edgeData = nodeData.undirected[neighbor];
 
@@ -5402,9 +5405,9 @@ class Graph extends EventEmitter {
     this._nodes.delete(node);
 
     // Emitting
-    this.emit('nodeDropped', {
+    this.emit("nodeDropped", {
       key: node,
-      attributes: nodeData.attributes
+      attributes: nodeData.attributes,
     });
   }
 
@@ -5426,8 +5429,8 @@ class Graph extends EventEmitter {
     let edgeData;
 
     if (arguments.length > 1) {
-      const source = '' + arguments[0];
-      const target = '' + arguments[1];
+      const source = "" + arguments[0];
+      const target = "" + arguments[1];
 
       edgeData = getMatchingEdge(this, source, target, this.type);
 
@@ -5436,7 +5439,7 @@ class Graph extends EventEmitter {
           `Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`
         );
     } else {
-      edge = '' + edge;
+      edge = "" + edge;
 
       edgeData = this._edges.get(edge);
 
@@ -5464,18 +5467,18 @@ class Graph extends EventEmitter {
   dropDirectedEdge(source, target) {
     if (arguments.length < 2)
       throw new UsageGraphError(
-        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'
+        "Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."
       );
 
     if (this.multi)
       throw new UsageGraphError(
-        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'
+        "Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."
       );
 
-    source = '' + source;
-    target = '' + target;
+    source = "" + source;
+    target = "" + target;
 
-    const edgeData = getMatchingEdge(this, source, target, 'directed');
+    const edgeData = getMatchingEdge(this, source, target, "directed");
 
     if (!edgeData)
       throw new NotFoundGraphError(
@@ -5500,15 +5503,15 @@ class Graph extends EventEmitter {
   dropUndirectedEdge(source, target) {
     if (arguments.length < 2)
       throw new UsageGraphError(
-        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'
+        "Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead."
       );
 
     if (this.multi)
       throw new UsageGraphError(
-        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'
+        "Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones."
       );
 
-    const edgeData = getMatchingEdge(this, source, target, 'undirected');
+    const edgeData = getMatchingEdge(this, source, target, "undirected");
 
     if (!edgeData)
       throw new NotFoundGraphError(
@@ -5536,7 +5539,7 @@ class Graph extends EventEmitter {
     this._resetInstanceCounters();
 
     // Emitting
-    this.emit('cleared');
+    this.emit("cleared");
   }
 
   /**
@@ -5561,7 +5564,7 @@ class Graph extends EventEmitter {
     this._resetInstanceCounters();
 
     // Emitting
-    this.emit('edgesCleared');
+    this.emit("edgesCleared");
   }
 
   /**---------------------------------------------------------------------------
@@ -5609,10 +5612,10 @@ class Graph extends EventEmitter {
     this._attributes[name] = value;
 
     // Emitting
-    this.emit('attributesUpdated', {
-      type: 'set',
+    this.emit("attributesUpdated", {
+      type: "set",
       attributes: this._attributes,
-      name
+      name,
     });
 
     return this;
@@ -5626,9 +5629,9 @@ class Graph extends EventEmitter {
    * @return {Graph}
    */
   updateAttribute(name, updater) {
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.updateAttribute: updater should be a function.'
+        "Graph.updateAttribute: updater should be a function."
       );
 
     const value = this._attributes[name];
@@ -5636,10 +5639,10 @@ class Graph extends EventEmitter {
     this._attributes[name] = updater(value);
 
     // Emitting
-    this.emit('attributesUpdated', {
-      type: 'set',
+    this.emit("attributesUpdated", {
+      type: "set",
       attributes: this._attributes,
-      name
+      name,
     });
 
     return this;
@@ -5655,10 +5658,10 @@ class Graph extends EventEmitter {
     delete this._attributes[name];
 
     // Emitting
-    this.emit('attributesUpdated', {
-      type: 'remove',
+    this.emit("attributesUpdated", {
+      type: "remove",
       attributes: this._attributes,
-      name
+      name,
     });
 
     return this;
@@ -5675,15 +5678,15 @@ class Graph extends EventEmitter {
   replaceAttributes(attributes) {
     if (!isPlainObject(attributes))
       throw new InvalidArgumentsGraphError(
-        'Graph.replaceAttributes: provided attributes are not a plain object.'
+        "Graph.replaceAttributes: provided attributes are not a plain object."
       );
 
     this._attributes = attributes;
 
     // Emitting
-    this.emit('attributesUpdated', {
-      type: 'replace',
-      attributes: this._attributes
+    this.emit("attributesUpdated", {
+      type: "replace",
+      attributes: this._attributes,
     });
 
     return this;
@@ -5700,16 +5703,16 @@ class Graph extends EventEmitter {
   mergeAttributes(attributes) {
     if (!isPlainObject(attributes))
       throw new InvalidArgumentsGraphError(
-        'Graph.mergeAttributes: provided attributes are not a plain object.'
+        "Graph.mergeAttributes: provided attributes are not a plain object."
       );
 
     assign(this._attributes, attributes);
 
     // Emitting
-    this.emit('attributesUpdated', {
-      type: 'merge',
+    this.emit("attributesUpdated", {
+      type: "merge",
       attributes: this._attributes,
-      data: attributes
+      data: attributes,
     });
 
     return this;
@@ -5724,17 +5727,17 @@ class Graph extends EventEmitter {
    * @throws {Error} - Will throw if given updater is not a function.
    */
   updateAttributes(updater) {
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.updateAttributes: provided updater is not a function.'
+        "Graph.updateAttributes: provided updater is not a function."
       );
 
     this._attributes = updater(this._attributes);
 
     // Emitting
-    this.emit('attributesUpdated', {
-      type: 'update',
-      attributes: this._attributes
+    this.emit("attributesUpdated", {
+      type: "update",
+      attributes: this._attributes,
     });
 
     return this;
@@ -5747,14 +5750,14 @@ class Graph extends EventEmitter {
    * @param {object}    [hints] - Optional hints.
    */
   updateEachNodeAttributes(updater, hints) {
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.updateEachNodeAttributes: expecting an updater function.'
+        "Graph.updateEachNodeAttributes: expecting an updater function."
       );
 
     if (hints && !validateHints(hints))
       throw new InvalidArgumentsGraphError(
-        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'
+        "Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"
       );
 
     const iterator = this._nodes.values();
@@ -5766,8 +5769,8 @@ class Graph extends EventEmitter {
       nodeData.attributes = updater(nodeData.key, nodeData.attributes);
     }
 
-    this.emit('eachNodeAttributesUpdated', {
-      hints: hints ? hints : null
+    this.emit("eachNodeAttributesUpdated", {
+      hints: hints ? hints : null,
     });
   }
 
@@ -5778,14 +5781,14 @@ class Graph extends EventEmitter {
    * @param {object}    [hints] - Optional hints.
    */
   updateEachEdgeAttributes(updater, hints) {
-    if (typeof updater !== 'function')
+    if (typeof updater !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.updateEachEdgeAttributes: expecting an updater function.'
+        "Graph.updateEachEdgeAttributes: expecting an updater function."
       );
 
     if (hints && !validateHints(hints))
       throw new InvalidArgumentsGraphError(
-        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'
+        "Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}"
       );
 
     const iterator = this._edges.values();
@@ -5808,8 +5811,8 @@ class Graph extends EventEmitter {
       );
     }
 
-    this.emit('eachEdgeAttributesUpdated', {
-      hints: hints ? hints : null
+    this.emit("eachEdgeAttributesUpdated", {
+      hints: hints ? hints : null,
     });
   }
 
@@ -5824,17 +5827,17 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback to use.
    */
   forEachAdjacencyEntry(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.forEachAdjacencyEntry: expecting a callback.'
+        "Graph.forEachAdjacencyEntry: expecting a callback."
       );
 
     forEachAdjacency(false, false, false, this, callback);
   }
   forEachAdjacencyEntryWithOrphans(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'
+        "Graph.forEachAdjacencyEntryWithOrphans: expecting a callback."
       );
 
     forEachAdjacency(false, false, true, this, callback);
@@ -5846,17 +5849,17 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback to use.
    */
   forEachAssymetricAdjacencyEntry(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'
+        "Graph.forEachAssymetricAdjacencyEntry: expecting a callback."
       );
 
     forEachAdjacency(false, true, false, this, callback);
   }
   forEachAssymetricAdjacencyEntryWithOrphans(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'
+        "Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback."
       );
 
     forEachAdjacency(false, true, true, this, callback);
@@ -5868,7 +5871,7 @@ class Graph extends EventEmitter {
    * @return {array} - The nodes.
    */
   nodes() {
-    if (typeof Array.from === 'function') return Array.from(this._nodes.keys());
+    if (typeof Array.from === "function") return Array.from(this._nodes.keys());
 
     return take(this._nodes.keys(), this._nodes.size);
   }
@@ -5879,9 +5882,9 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback (key, attributes, index).
    */
   forEachNode(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.forEachNode: expecting a callback.'
+        "Graph.forEachNode: expecting a callback."
       );
 
     const iterator = this._nodes.values();
@@ -5901,9 +5904,9 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback (key, attributes).
    */
   findNode(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.findNode: expecting a callback.'
+        "Graph.findNode: expecting a callback."
       );
 
     const iterator = this._nodes.values();
@@ -5925,9 +5928,9 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback (key, attributes).
    */
   mapNodes(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.mapNode: expecting a callback.'
+        "Graph.mapNode: expecting a callback."
       );
 
     const iterator = this._nodes.values();
@@ -5951,9 +5954,9 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback (key, attributes).
    */
   someNode(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.someNode: expecting a callback.'
+        "Graph.someNode: expecting a callback."
       );
 
     const iterator = this._nodes.values();
@@ -5975,9 +5978,9 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback (key, attributes).
    */
   everyNode(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.everyNode: expecting a callback.'
+        "Graph.everyNode: expecting a callback."
       );
 
     const iterator = this._nodes.values();
@@ -5999,9 +6002,9 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback (key, attributes).
    */
   filterNodes(callback) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.filterNodes: expecting a callback.'
+        "Graph.filterNodes: expecting a callback."
       );
 
     const iterator = this._nodes.values();
@@ -6026,14 +6029,14 @@ class Graph extends EventEmitter {
    * @param  {function}  callback - Callback (accumulator, key, attributes).
    */
   reduceNodes(callback, initialValue) {
-    if (typeof callback !== 'function')
+    if (typeof callback !== "function")
       throw new InvalidArgumentsGraphError(
-        'Graph.reduceNodes: expecting a callback.'
+        "Graph.reduceNodes: expecting a callback."
       );
 
     if (arguments.length < 2)
       throw new InvalidArgumentsGraphError(
-        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'
+        "Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."
       );
 
     let accumulator = initialValue;
@@ -6066,8 +6069,8 @@ class Graph extends EventEmitter {
       const data = step.value;
 
       return {
-        value: {node: data.key, attributes: data.attributes},
-        done: false
+        value: { node: data.key, attributes: data.attributes },
+        done: false,
       };
     });
   }
@@ -6103,11 +6106,11 @@ class Graph extends EventEmitter {
       options: {
         type: this.type,
         multi: this.multi,
-        allowSelfLoops: this.allowSelfLoops
+        allowSelfLoops: this.allowSelfLoops,
       },
       attributes: this.getAttributes(),
       nodes,
-      edges
+      edges,
     };
   }
 
@@ -6144,13 +6147,13 @@ class Graph extends EventEmitter {
     // Importing a serialized graph
     if (!isPlainObject(data))
       throw new InvalidArgumentsGraphError(
-        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'
+        "Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance."
       );
 
     if (data.attributes) {
       if (!isPlainObject(data.attributes))
         throw new InvalidArgumentsGraphError(
-          'Graph.import: invalid attributes. Expecting a plain object.'
+          "Graph.import: invalid attributes. Expecting a plain object."
         );
 
       if (merge) this.mergeAttributes(data.attributes);
@@ -6164,7 +6167,7 @@ class Graph extends EventEmitter {
 
       if (!Array.isArray(list))
         throw new InvalidArgumentsGraphError(
-          'Graph.import: invalid nodes. Expecting an array.'
+          "Graph.import: invalid nodes. Expecting an array."
         );
 
       for (i = 0, l = list.length; i < l; i++) {
@@ -6174,7 +6177,7 @@ class Graph extends EventEmitter {
         validateSerializedNode(node);
 
         // Adding the node
-        const {key, attributes} = node;
+        const { key, attributes } = node;
 
         if (merge) this.mergeNode(key, attributes);
         else this.addNode(key, attributes);
@@ -6184,7 +6187,7 @@ class Graph extends EventEmitter {
     if (data.edges) {
       let undirectedByDefault = false;
 
-      if (this.type === 'undirected') {
+      if (this.type === "undirected") {
         undirectedByDefault = true;
       }
 
@@ -6192,7 +6195,7 @@ class Graph extends EventEmitter {
 
       if (!Array.isArray(list))
         throw new InvalidArgumentsGraphError(
-          'Graph.import: invalid edges. Expecting an array.'
+          "Graph.import: invalid edges. Expecting an array."
         );
 
       for (i = 0, l = list.length; i < l; i++) {
@@ -6206,12 +6209,12 @@ class Graph extends EventEmitter {
           source,
           target,
           attributes,
-          undirected = undirectedByDefault
+          undirected = undirectedByDefault,
         } = edge;
 
         let method;
 
-        if ('key' in edge) {
+        if ("key" in edge) {
           method = merge
             ? undirected
               ? this.mergeUndirectedEdgeWithKey
@@ -6287,30 +6290,30 @@ class Graph extends EventEmitter {
     options = options || {};
 
     if (
-      typeof options.type === 'string' &&
+      typeof options.type === "string" &&
       options.type !== this.type &&
-      options.type !== 'mixed'
+      options.type !== "mixed"
     )
       throw new UsageGraphError(
         `Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${options.type}" because this would mean losing information about the current graph.`
       );
 
     if (
-      typeof options.multi === 'boolean' &&
+      typeof options.multi === "boolean" &&
       options.multi !== this.multi &&
       options.multi !== true
     )
       throw new UsageGraphError(
-        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'
+        "Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph."
       );
 
     if (
-      typeof options.allowSelfLoops === 'boolean' &&
+      typeof options.allowSelfLoops === "boolean" &&
       options.allowSelfLoops !== this.allowSelfLoops &&
       options.allowSelfLoops !== true
     )
       throw new UsageGraphError(
-        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'
+        "Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph."
       );
 
     const graph = this.emptyCopy(options);
@@ -6325,7 +6328,7 @@ class Graph extends EventEmitter {
       // NOTE: no need to emit events since user cannot access the instance yet
       addEdge(
         graph,
-        'copy',
+        "copy",
         false,
         edgeData.undirected,
         edgeData.key,
@@ -6356,7 +6359,7 @@ class Graph extends EventEmitter {
    * Method returning [object Graph].
    */
   toString() {
-    return '[object Graph]';
+    return "[object Graph]";
   }
 
   /**
@@ -6374,9 +6377,9 @@ class Graph extends EventEmitter {
       multiIndex = {};
 
     this._edges.forEach((data, key) => {
-      const direction = data.undirected ? '--' : '->';
+      const direction = data.undirected ? "--" : "->";
 
-      let label = '';
+      let label = "";
 
       let source = data.source.key;
       let target = data.target.key;
@@ -6390,10 +6393,10 @@ class Graph extends EventEmitter {
 
       const desc = `(${source})${direction}(${target})`;
 
-      if (!key.startsWith('geid_')) {
+      if (!key.startsWith("geid_")) {
         label += `[${key}]: `;
       } else if (this.multi) {
-        if (typeof multiIndex[desc] === 'undefined') {
+        if (typeof multiIndex[desc] === "undefined") {
           multiIndex[desc] = 0;
         } else {
           multiIndex[desc]++;
@@ -6413,8 +6416,8 @@ class Graph extends EventEmitter {
       if (
         this.hasOwnProperty(k) &&
         !EMITTER_PROPS.has(k) &&
-        typeof this[k] !== 'function' &&
-        typeof k !== 'symbol'
+        typeof this[k] !== "function" &&
+        typeof k !== "symbol"
       )
         dummy[k] = this[k];
     }
@@ -6423,7 +6426,7 @@ class Graph extends EventEmitter {
     dummy.nodes = nodes;
     dummy.edges = edges;
 
-    privateProperty(dummy, 'constructor', this.constructor);
+    privateProperty(dummy, "constructor", this.constructor);
 
     return dummy;
   }
@@ -6440,17 +6443,17 @@ class Graph extends EventEmitter {
 /**
  * Attaching custom inspect method for node >= 10.
  */
-if (typeof Symbol !== 'undefined')
-  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =
+if (typeof Symbol !== "undefined")
+  Graph.prototype[Symbol.for("nodejs.util.inspect.custom")] =
     Graph.prototype.inspect;
 
 /**
  * Related to edge addition.
  */
-EDGE_ADD_METHODS.forEach(method => {
-  ['add', 'merge', 'update'].forEach(verb => {
+EDGE_ADD_METHODS.forEach((method) => {
+  ["add", "merge", "update"].forEach((verb) => {
     const name = method.name(verb);
-    const fn = verb === 'add' ? addEdge : mergeEdge;
+    const fn = verb === "add" ? addEdge : mergeEdge;
 
     if (method.generateKey) {
       Graph.prototype[name] = function (source, target, attributes) {
@@ -6458,12 +6461,12 @@ EDGE_ADD_METHODS.forEach(method => {
           this,
           name,
           true,
-          (method.type || this.type) === 'undirected',
+          (method.type || this.type) === "undirected",
           null,
           source,
           target,
           attributes,
-          verb === 'update'
+          verb === "update"
         );
       };
     } else {
@@ -6472,12 +6475,12 @@ EDGE_ADD_METHODS.forEach(method => {
           this,
           name,
           false,
-          (method.type || this.type) === 'undirected',
+          (method.type || this.type) === "undirected",
           edge,
           source,
           target,
           attributes,
-          verb === 'update'
+          verb === "update"
         );
       };
     }
@@ -6513,14 +6516,14 @@ attachNeighborIterationMethods(Graph);
  */
 class DirectedGraph extends Graph {
   constructor(options) {
-    const finalOptions = assign({type: 'directed'}, options);
+    const finalOptions = assign({ type: "directed" }, options);
 
-    if ('multi' in finalOptions && finalOptions.multi !== false)
+    if ("multi" in finalOptions && finalOptions.multi !== false)
       throw new InvalidArgumentsGraphError(
-        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'
+        "DirectedGraph.from: inconsistent indication that the graph should be multi in given options!"
       );
 
-    if (finalOptions.type !== 'directed')
+    if (finalOptions.type !== "directed")
       throw new InvalidArgumentsGraphError(
         'DirectedGraph.from: inconsistent "' +
           finalOptions.type +
@@ -6532,14 +6535,14 @@ class DirectedGraph extends Graph {
 }
 class UndirectedGraph extends Graph {
   constructor(options) {
-    const finalOptions = assign({type: 'undirected'}, options);
+    const finalOptions = assign({ type: "undirected" }, options);
 
-    if ('multi' in finalOptions && finalOptions.multi !== false)
+    if ("multi" in finalOptions && finalOptions.multi !== false)
       throw new InvalidArgumentsGraphError(
-        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'
+        "UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!"
       );
 
-    if (finalOptions.type !== 'undirected')
+    if (finalOptions.type !== "undirected")
       throw new InvalidArgumentsGraphError(
         'UndirectedGraph.from: inconsistent "' +
           finalOptions.type +
@@ -6551,11 +6554,11 @@ class UndirectedGraph extends Graph {
 }
 class MultiGraph extends Graph {
   constructor(options) {
-    const finalOptions = assign({multi: true}, options);
+    const finalOptions = assign({ multi: true }, options);
 
-    if ('multi' in finalOptions && finalOptions.multi !== true)
+    if ("multi" in finalOptions && finalOptions.multi !== true)
       throw new InvalidArgumentsGraphError(
-        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'
+        "MultiGraph.from: inconsistent indication that the graph should be simple in given options!"
       );
 
     super(finalOptions);
@@ -6563,14 +6566,14 @@ class MultiGraph extends Graph {
 }
 class MultiDirectedGraph extends Graph {
   constructor(options) {
-    const finalOptions = assign({type: 'directed', multi: true}, options);
+    const finalOptions = assign({ type: "directed", multi: true }, options);
 
-    if ('multi' in finalOptions && finalOptions.multi !== true)
+    if ("multi" in finalOptions && finalOptions.multi !== true)
       throw new InvalidArgumentsGraphError(
-        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'
+        "MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!"
       );
 
-    if (finalOptions.type !== 'directed')
+    if (finalOptions.type !== "directed")
       throw new InvalidArgumentsGraphError(
         'MultiDirectedGraph.from: inconsistent "' +
           finalOptions.type +
@@ -6582,14 +6585,14 @@ class MultiDirectedGraph extends Graph {
 }
 class MultiUndirectedGraph extends Graph {
   constructor(options) {
-    const finalOptions = assign({type: 'undirected', multi: true}, options);
+    const finalOptions = assign({ type: "undirected", multi: true }, options);
 
-    if ('multi' in finalOptions && finalOptions.multi !== true)
+    if ("multi" in finalOptions && finalOptions.multi !== true)
       throw new InvalidArgumentsGraphError(
-        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'
+        "MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!"
       );
 
-    if (finalOptions.type !== 'undirected')
+    if (finalOptions.type !== "undirected")
       throw new InvalidArgumentsGraphError(
         'MultiUndirectedGraph.from: inconsistent "' +
           finalOptions.type +
@@ -6647,5 +6650,16 @@ Graph.UsageGraphError = UsageGraphError;
  * Endpoint for ESM modules consumers.
  */
 
-export { DirectedGraph, Graph, InvalidArgumentsGraphError, MultiDirectedGraph, MultiGraph, MultiUndirectedGraph, NotFoundGraphError, UndirectedGraph, UsageGraphError, Graph as default };
+export {
+  DirectedGraph,
+  Graph,
+  InvalidArgumentsGraphError,
+  MultiDirectedGraph,
+  MultiGraph,
+  MultiUndirectedGraph,
+  NotFoundGraphError,
+  UndirectedGraph,
+  UsageGraphError,
+  Graph as default,
+};
 //# sourceMappingURL=graphology.esm.js.map
